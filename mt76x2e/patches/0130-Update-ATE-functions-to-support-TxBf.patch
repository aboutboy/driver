From 3099451f69b3ab03d5857bf793e55c58228c2a64 Mon Sep 17 00:00:00 2001
From: Lea <liweiqiang@xcloud.cc>
Date: Mon, 6 Mar 2017 15:43:44 +0800
Subject: [PATCH] Update ATE functions to support TxBf.

---
 mt76x2/ate/chips/mt76x2_ate.c          |   84 +-
 mt76x2/ate/chips/rt28xx_ate.c          |    0
 mt76x2/ate/chips/rt6352_ate.c          |    0
 mt76x2/ate/chips/rt6590_ate.c          |  581 ++++++--
 mt76x2/ate/chips/rt85592_ate.c         |    0
 mt76x2/ate/common/ate_pci.c            |   22 +
 mt76x2/ate/common/rt_ate.c             | 1409 +++++++++++++++-----
 mt76x2/ate/common/rt_qa.c              |   46 +-
 mt76x2/ate/include/rt_ate.h            |   68 +-
 mt76x2/ate/include/rt_qa.h             |    0
 mt76x2/chips/mt76x2.c                  |    2 +-
 mt76x2/common/action.c                 |    5 +-
 mt76x2/common/cmm_info.c               |    7 +-
 mt76x2/common/cmm_profile.c            |    2 +-
 mt76x2/common/cmm_txbf.c               |    3 +
 mt76x2/include/mac_ral/nmac/ral_nmac.h |    8 +-
 16 files changed, 1719 insertions(+), 518 deletions(-)
 mode change 100644 => 100755 mt76x2/ate/chips/mt76x2_ate.c
 mode change 100644 => 100755 mt76x2/ate/chips/rt28xx_ate.c
 mode change 100644 => 100755 mt76x2/ate/chips/rt6352_ate.c
 mode change 100644 => 100755 mt76x2/ate/chips/rt6590_ate.c
 mode change 100644 => 100755 mt76x2/ate/chips/rt85592_ate.c
 mode change 100644 => 100755 mt76x2/ate/common/ate_pci.c
 mode change 100644 => 100755 mt76x2/ate/common/rt_ate.c
 mode change 100644 => 100755 mt76x2/ate/common/rt_qa.c
 mode change 100644 => 100755 mt76x2/ate/include/rt_ate.h
 mode change 100644 => 100755 mt76x2/ate/include/rt_qa.h

diff --git a/mt76x2/ate/chips/mt76x2_ate.c b/mt76x2/ate/chips/mt76x2_ate.c
old mode 100644
new mode 100755
index 90ce87c..0d55dd1
--- a/mt76x2/ate/chips/mt76x2_ate.c
+++ b/mt76x2/ate/chips/mt76x2_ate.c
@@ -66,7 +66,7 @@ static void mt76x2_ate_switch_channel(RTMP_ADAPTER *ad)
 {
 	PATE_INFO pATEInfo = &(ad->ate);
 	unsigned int latch_band, band, bw, tx_rx_setting;
-	UINT32 ret, i, value, value1, restore_value, loop = 0;
+	UINT32 i, value, value1, restore_value, loop = 0;
 	UCHAR bbp_ch_idx = 0;
 	BOOLEAN band_change = FALSE;
 	u8 channel = 0;
@@ -74,6 +74,7 @@ static void mt76x2_ate_switch_channel(RTMP_ADAPTER *ad)
 	CHAR RxAntennaSel = pATEInfo->RxAntennaSel;
 	UINT32 eLNA_gain_from_e2p = 0;
 
+
 	SYNC_CHANNEL_WITH_QA(pATEInfo, &channel);
 
 
@@ -509,8 +510,7 @@ INT mt76x2_ate_tx_pwr_Evaluation(
 	UCHAR channel = pATEInfo->Channel;
 	UCHAR bw = pATEInfo->TxWI.TXWI_N.BW;
 	UINT16 value, value1;
-	INT ret = TRUE;
-
+ 
 	if ( channel > 14 )
 	{
 		/* Get BW PWR DELTA */
@@ -1305,7 +1305,7 @@ VOID mt76x2_ate_set_tx_rx(
 					/* 0x2714[7:0]=0 (default) */
 					RTMP_BBP_IO_READ32(ad, TXBE_R5, &BbpValue);
 					BbpValue &= 0xFFFFFF00;
-					BbpValue |= 0x00000083;
+					BbpValue |= 0x00000003;
 					RTMP_BBP_IO_WRITE32(ad, TXBE_R5, BbpValue);
 					}
 
@@ -1411,11 +1411,8 @@ INT	mt76x2_set_ate_tx_bw_proc(
 {
 	u32 core, core_r1 = 0, core_r4 = 0;
 	u32 agc, agc_r0 = 0;
-	u32 ret;
 	u8 BBPCurrentBW;
-	RTMP_CHIP_CAP *pChipCap = &ad->chipCap;
 
-	
 	BBPCurrentBW = simple_strtol(arg, 0, 10);
 
 	if ((BBPCurrentBW == 0))
@@ -1430,10 +1427,6 @@ INT	mt76x2_set_ate_tx_bw_proc(
 	{
 		ad->ate.TxWI.TXWI_N.BW = BW_80;
  	}
-	else if ((BBPCurrentBW == 4))
-	{
-		//ad->ate.TxWI.TXWI_N.BW = BW_10;
- 	}
 	else
 	{
 		DBGPRINT(RT_DEBUG_ERROR, ("Set_ATE_TX_BW_Proc!! Error!! Unknow bw.\n"));
@@ -1477,10 +1470,6 @@ INT	mt76x2_set_ate_tx_bw_proc(
 			core &= (~0x18);
 			agc |= 0x1000;
 			break;
-// 		case BW_10:
-// 			core |= 0x08;
-// 			agc |= 0x1000;
-// 			break;
	}
 
 	if (core != core_r1) 
@@ -1543,7 +1532,14 @@ void mt76x2_ate_temp_tx_alc(RTMP_ADAPTER *ad)
 {
 	RTMP_CHIP_CAP *pChipCap = &ad->chipCap;
 	INT32 temp_diff = 0, dB_diff = 0, tx0_temp_comp = 0, tx1_temp_comp = 0;
+	UCHAR tc_init_val = 0;
+
+#ifdef SINGLE_SKU_V2
+	tc_init_val = ad->tc_init_val;
 
+	if (ad->sku_init_done == FALSE)
+		return;
+#endif /* SINGLE_SKU_V2 */
 	if (pChipCap->temp_tx_alc_enable) {
 		mt76x2_get_current_temp(ad);
 		temp_diff = pChipCap->current_temp - 25;
@@ -1556,6 +1552,9 @@ void mt76x2_ate_temp_tx_alc(RTMP_ADAPTER *ad)
 			else
 				dB_diff = 0;
 			
+			DBGPRINT(RT_DEBUG_TRACE, ("%s::[5G] temp_diff=%d (0x%x), dB_diff=%d (0x%x)\n", 
+				__FUNCTION__, temp_diff, temp_diff, dB_diff, dB_diff)); 			
+			
 			/* temperature compensation boundary check and limit */
 			dB_diff = (dB_diff > pChipCap->tc_upper_bound_a_band) ? pChipCap->tc_upper_bound_a_band : dB_diff;
 			dB_diff = (dB_diff < pChipCap->tc_lower_bound_a_band) ? pChipCap->tc_lower_bound_a_band : dB_diff;
@@ -1567,26 +1566,29 @@ void mt76x2_ate_temp_tx_alc(RTMP_ADAPTER *ad)
 			else
 				dB_diff = 0;
 
+			DBGPRINT(RT_DEBUG_TRACE, ("%s::[2G] temp_diff=%d (0x%x), dB_diff=%d (0x%x)\n", 
+				__FUNCTION__, temp_diff, temp_diff, dB_diff, dB_diff)); 
+			
 			/* temperature compensation boundary check and limit */
 			dB_diff = (dB_diff > pChipCap->tc_upper_bound_g_band) ? pChipCap->tc_upper_bound_g_band : dB_diff;
 			dB_diff = (dB_diff < pChipCap->tc_lower_bound_g_band) ? pChipCap->tc_lower_bound_g_band : dB_diff;
 		}
 
-		DBGPRINT(RT_DEBUG_INFO, ("%s::temp_diff=%d (0x%x), dB_diff=%d (0x%x)\n", 
+		DBGPRINT(RT_DEBUG_TRACE, ("%s::temp_diff=%d (0x%x), dB_diff=%d (0x%x)\n", 
 			__FUNCTION__, temp_diff, temp_diff, dB_diff, dB_diff)); 
 		
 		RTMP_IO_READ32(ad, TX_ALC_CFG_1, &tx0_temp_comp);
 		tx0_temp_comp &= ~TX_ALC_CFG_1_TX0_TEMP_COMP_MASK;
-		tx0_temp_comp |= (dB_diff*2 & TX_ALC_CFG_1_TX0_TEMP_COMP_MASK);
+		tx0_temp_comp |= ((tc_init_val + dB_diff*2) & TX_ALC_CFG_1_TX0_TEMP_COMP_MASK);
 		RTMP_IO_WRITE32(ad, TX_ALC_CFG_1, tx0_temp_comp);
-		DBGPRINT(RT_DEBUG_INFO, ("%s::Tx0 power compensation = 0x%x\n", 
+		DBGPRINT(RT_DEBUG_TRACE, ("%s::Tx0 power compensation = 0x%x\n", 
 			__FUNCTION__, tx0_temp_comp & 0x3f)); 
 		
 		RTMP_IO_READ32(ad, TX_ALC_CFG_2, &tx1_temp_comp);
 		tx1_temp_comp &= ~TX_ALC_CFG_2_TX1_TEMP_COMP_MASK;
-		tx1_temp_comp |= (dB_diff*2 & TX_ALC_CFG_2_TX1_TEMP_COMP_MASK);
+		tx1_temp_comp |= ((tc_init_val + dB_diff*2) & TX_ALC_CFG_2_TX1_TEMP_COMP_MASK);
 		RTMP_IO_WRITE32(ad, TX_ALC_CFG_2, tx1_temp_comp);
-		DBGPRINT(RT_DEBUG_INFO, ("%s::Tx1 power compensation = 0x%x\n", 
+		DBGPRINT(RT_DEBUG_TRACE, ("%s::Tx1 power compensation = 0x%x\n", 
 			__FUNCTION__, tx1_temp_comp & 0x3f)); 
 	}	
 }
@@ -1720,12 +1722,12 @@ VOID mt76x2_ate_asic_adjust_tx_power(
 	RTMP_CHIP_CAP *cap = &pAd->chipCap;
 	ANDES_CALIBRATION_PARAM param;
 	UINT32 pa_mode = 0, tssi_slope_offset = 0;
-	UINT32 ret = 0;
 	PATE_INFO   pATEInfo = &(pAd->ate);
 	UINT32 value;
 	char TxPower = 0;
 
 
+
 	if ((pAd->chipCap.tssi_enable) &&
 			(RTMP_TEST_FLAG(pAd, fRTMP_ADAPTER_RADIO_OFF | 
 				fRTMP_ADAPTER_DISABLE_DEQUEUEPACKET) == FALSE)) {
@@ -2128,7 +2130,6 @@ extern UCHAR TemplateFrame[32];
 
 VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 {
-	UINT32	ring_index=0;
 	RTMP_TX_RING *pTxRing = &pAd->TxRing[QID_AC_BE];
 	PATE_INFO   pATEInfo = &(pAd->ate);
 	UINT32 TxIdx = pTxRing->TxCpuIdx;
@@ -2140,7 +2141,7 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 
 	PHEADER_802_11 pHeader_802_11;
 	ULONG Length;
-	UINT pos = 0;
+	/*UINT pos = 0;*/
 	TXINFO_STRUC *pTxInfo;
 
 #ifdef RT_BIG_ENDIAN
@@ -2148,7 +2149,7 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 	UCHAR tx_hw_info[TXD_SIZE];
 #endif /* RT_BIG_ENDIAN */
 	PNDIS_PACKET pPacket=NULL;
-	PUCHAR pDest=NULL;
+	/*PUCHAR pDest=NULL;*/
 	PVOID AllocVa=NULL;
 	NDIS_PHYSICAL_ADDRESS AllocPa;
 	HTTRANSMIT_SETTING	TxHTPhyMode;
@@ -2157,8 +2158,7 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 	PUCHAR pDMAHeaderBufVA = (PUCHAR) pTxRing->Cell[TxIdx].DmaBuf.AllocVa;
 	UINT8 TXWISize = pAd->chipCap.TXWISize;
 
-	UCHAR bw, sgi, stbc, mcs, phy_mode, frag, cfack, ts, ampdu, ack, nseq, bawinsize, pkt_id, txop;
-	USHORT byte_cnt;
+	UCHAR bw, sgi, stbc, mcs, phy_mode;
 
 	RTMP_IO_READ32(pAd, pTxRing->hw_didx_addr, &pTxRing->TxDmaIdx);
 	pTxRing->TxSwFreeIdx = pTxRing->TxDmaIdx;
@@ -2203,9 +2203,7 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 	WriteBackToDescriptor((PUCHAR)pDestTxD, (PUCHAR)pTxD, FALSE, TYPE_TXD);
 #endif /* RT_BIG_ENDIAN */
 
-	bw = sgi = stbc = mcs = phy_mode = frag = cfack = ts =0;
-	ampdu = ack = nseq = bawinsize = pkt_id = txop = 0;
-	byte_cnt = 0;
+	bw = sgi = stbc = mcs = phy_mode = 0;
 #ifdef RLT_MAC
 	if (pAd->chipCap.hif_type == HIF_RLT) {
 		bw = pATEInfo->TxWI.TXWI_N.BW;
@@ -2213,18 +2211,6 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 		stbc = pATEInfo->TxWI.TXWI_N.STBC;
 		mcs = pATEInfo->TxWI.TXWI_N.MCS;
 		phy_mode = pATEInfo->TxWI.TXWI_N.PHYMODE;
-			
-		frag = pATEInfo->TxWI.TXWI_N.FRAG;
-		cfack = pATEInfo->TxWI.TXWI_N.CFACK,
-		ts = pATEInfo->TxWI.TXWI_N.TS;
-		ampdu = pATEInfo->TxWI.TXWI_N.AMPDU;
-		ack = pATEInfo->TxWI.TXWI_N.ACK;
-		nseq = pATEInfo->TxWI.TXWI_N.NSEQ;
-		bawinsize =pATEInfo->TxWI.TXWI_N.BAWinSize;
-		byte_cnt = pATEInfo->TxWI.TXWI_N.MPDUtotalByteCnt;
-		pkt_id = pATEInfo->TxWI.TXWI_N.TxPktId;
-		txop = pATEInfo->TxWI.TXWI_N.txop;
-		cfack = pATEInfo->TxWI.TXWI_N.CFACK;
 	}
 #endif /* RLT_MAC */
 
@@ -2248,8 +2234,8 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 	//COPY_MAC_ADDR(pHeader_802_11->Addr2, pATEInfo->Addr2);
 	//COPY_MAC_ADDR(pHeader_802_11->Addr3, pATEInfo->Addr3);
 	COPY_MAC_ADDR(pHeader_802_11->Addr1, pATEInfo->Addr1);
-	COPY_MAC_ADDR(pHeader_802_11->Addr2, pATEInfo->Addr2);
-	COPY_MAC_ADDR(pHeader_802_11->Addr3, pATEInfo->Addr3);
+	COPY_MAC_ADDR(pHeader_802_11->Addr2, pATEInfo->Addr3);
+	COPY_MAC_ADDR(pHeader_802_11->Addr3, pATEInfo->Addr2);
 
 	pHeader_802_11->FC.PwrMgmt = 0;
 
@@ -2277,7 +2263,7 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 	}
 
 	pTxRing->Cell[TxIdx].pNextNdisPacket = pPacket;
-	pDest = (PUCHAR) AllocVa;
+	/*pDest = (PUCHAR) AllocVa;*/
 
 	GET_OS_PKT_LEN(pPacket) = pATEInfo->TxLength - pATEInfo->HLen;
 #ifndef LINUX
@@ -2303,7 +2289,12 @@ VOID mt76x2_ate_SendNullFrame(IN PRTMP_ADAPTER pAd)
 		/* build Tx descriptor */
 		pTxD->SDPtr0 = RTMP_GetPhysicalAddressLow (pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 		pTxD->SDLen0 = TXWISize + pATEInfo->HLen /* LENGTH_802_11 */;
+#ifndef RT_SECURE_DMA
 		pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, &txblk, 0, 1, RTMP_PCI_DMA_TODEVICE);
+#else
+		NdisMoveMemory(pAd->TxSecureDMA[QID_AC_BE].AllocVa + (TxIdx * 4096), &txblk, GET_OS_PKT_LEN(pPacket));
+		pTxD->SDPtr1 = pAd->TxSecureDMA[QID_AC_BE].AllocPa + (TxIdx * 4096);
+#endif
 		pTxD->SDLen1 = GET_OS_PKT_LEN(pPacket);
 		pTxD->LastSec0 = (pTxD->SDLen1 == 0) ? 1 : 0;
 		pTxD->LastSec1 = 1;
@@ -2343,11 +2334,10 @@ static void mt76x2_ate_single_sku(IN PRTMP_ADAPTER	pAd, IN BOOLEAN value)
 	
 	if (value > 0)
 	{
-		pATEInfo->bDoSingleSKU = TRUE;
+		pATEInfo->bDoSingleSKU = TRUE;			
 		/* force reconfiguration of the channel , to apply single sku value */
 		pATEInfo->PreviousChannel = 0;
-		DBGPRINT(RT_DEBUG_ERROR, ("ATESINGLESKU = TRUE , enabled single sku in ATE! \
-		Force switch channel to calculate single sku\n"));
+		DBGPRINT(RT_DEBUG_ERROR, ("ATESINGLESKU = TRUE , enabled single sku in ATE! Force switch channel to calculate single sku\n"));
 	}
 	else
 	{
diff --git a/mt76x2/ate/chips/rt28xx_ate.c b/mt76x2/ate/chips/rt28xx_ate.c
old mode 100644
new mode 100755
diff --git a/mt76x2/ate/chips/rt6352_ate.c b/mt76x2/ate/chips/rt6352_ate.c
old mode 100644
new mode 100755
diff --git a/mt76x2/ate/chips/rt6590_ate.c b/mt76x2/ate/chips/rt6590_ate.c
old mode 100644
new mode 100755
index 7162dd1..60fbe58
--- a/mt76x2/ate/chips/rt6590_ate.c
+++ b/mt76x2/ate/chips/rt6590_ate.c
@@ -205,6 +205,11 @@ static VOID MT76x0ATEAsicSwitchChannel(
 
 	RtmpusecDelay(100000);
 
+	
+#ifdef SINGLE_SKU_V2
+	if(pATEInfo->bDoSingleSKU)
+		MT76x0_single_sku(pAd,Channel);
+#endif /* SINGLE_SKU_V2 */
 	return;
 }
 
@@ -443,76 +448,7 @@ static UCHAR CurrentPower1;
 
 #define DEFAULT_BO              4
 #define LIN2DB_ERROR_CODE       (-10000)
-static INT16 lin2dBd(
-	IN	unsigned short linearValue)
-{
-    short exp;
-    unsigned int mantisa;
-    int app,dBd;
-
-	/* Default backoff ; to enhance leading bit searching time */
-	mantisa = linearValue << DEFAULT_BO;
-	exp = -(DEFAULT_BO);
-
-	/* Leading bit searching */
-	if (mantisa < (0x8000))
-	{
-		while (mantisa < (0x8000))
-		{
-			mantisa = mantisa << 1; /* no need saturation */
-			exp--;
-			if (exp < -20)
-			{
-				DBGPRINT_ERR(("input too small\n"));
-				DBGPRINT_ERR(("exponent = %d\n",exp));
-
-				return LIN2DB_ERROR_CODE;
-			}
-		}
-	}
-	else 
-	{
-		while (mantisa > (0xFFFF))
-		{
-			mantisa = mantisa >> 1; /* no need saturation */
-			exp ++;
-			if (exp > 20)
-			{
-				DBGPRINT_ERR(("input too large\n"));
-				DBGPRINT_ERR(("exponent = %d\n",exp));
-
-				return LIN2DB_ERROR_CODE;
-			}
-		}
-	}
-/*	printk("exp=0d%d,mantisa=0x%x\n",exp,mantisa); */
-
-	if (mantisa <= 47104)
-	{
-		app=(mantisa+(mantisa>>3)+(mantisa>>4)-38400); /* S(15,0) */
-		if (app<0)
-		{
-			app=0;
-		}
-	}
-	else
-	{
-		app=(mantisa-(mantisa>>3)-(mantisa>>6)-23040); /* S(15,0) */
-		if (app<0)
-		{
-			app=0;
-		}
-	}
-
-	dBd=((15+exp)<<15)+app; /*since 2^15=1 here */
-/*	printk("dBd1=%d\n",dBd); */
-	dBd=(dBd<<2)+(dBd<<1)+(dBd>>6)+(dBd>>7);
-	dBd=(dBd>>10); /* S10.5 */
-/*	printk("app=%d,dBd=%d,dBdF=%f\n",app,dBd,(double)dBd/32); */
-
-	return(dBd);
-}
-
+extern INT16 lin2dBd(IN unsigned short linearValue);
 
 VOID MT76x0ATE_MakeUpTssiTable(
 	IN RTMP_ADAPTER *pAd)
@@ -1468,6 +1404,194 @@ static VOID MT76x0ATETssiCompensation(
 #endif /* MT76x0_TSSI_CAL_COMPENSATION */
 
 
+#ifdef RTMP_TEMPERATURE_COMPENSATION
+extern BOOLEAN MT76x0_AsicGetTssiReport(
+	IN PRTMP_ADAPTER pAd,
+	IN BOOLEAN bResetTssiInfo,
+	OUT PCHAR pTssiReport);
+
+/* MaxBoundaryLevel MUST not be greater than the array size of TssiBoundary */
+static BOOLEAN MT76x0ATE_GetTemperatureCompensationLevel(
+	IN		PRTMP_ADAPTER	pAd,
+	IN		BOOLEAN			bAutoTxAgc,
+	IN		CHAR			TssiRef, /* e2p[75h]: the zero reference */
+	IN		PCHAR			pTssiMinusBoundary,
+	IN		PCHAR			pTssiPlusBoundary,
+	IN		UINT8			MaxBoundaryLevel,
+	IN		UINT8			TxAgcStep,
+	IN		CHAR			CurrTemperature,
+	OUT		PCHAR			pCompensationLevel)
+{
+	INT			idx;
+
+	/* sanity check */
+	if ((pTssiMinusBoundary == NULL) || (pTssiPlusBoundary == NULL))
+	{
+		DBGPRINT(RT_DEBUG_ERROR, 
+					("%s(): pTssiBoundary is NULL!\n",
+					__FUNCTION__)); 
+		return FALSE;
+	}
+
+	/* ATE ALC is not controlled by e2p */
+	if (1 /* bAutoTxAgc */)
+	{
+		if (CurrTemperature < pTssiMinusBoundary[1])
+		{
+			/*
+				reading is larger than the reference value check
+				for how large we need to decrease the Tx power
+			*/
+			for (idx = 1; idx < MaxBoundaryLevel; idx++)
+			{
+				if (CurrTemperature >= pTssiMinusBoundary[idx]) 
+					break; /* level range found */
+			}
+
+			/* 
+				the index is the step we should decrease,
+				idx = 0 means there is nothing to compensate
+			*/
+			*pCompensationLevel = -(TxAgcStep * (idx-1));
+			DBGPRINT(RT_DEBUG_TRACE, 
+						("-- Tx Power, CurrTemperature=%d, TssiRef=%d, TxAgcStep=%d, step = -%d, CompensationLevel = %d\n",
+			    			CurrTemperature, TssiRef, TxAgcStep, idx-1, *pCompensationLevel));                    
+		}
+		else if (CurrTemperature > pTssiPlusBoundary[1])
+		{
+			/*
+				reading is smaller than the reference value check
+				for how large we need to increase the Tx power
+			*/
+			for (idx = 1; idx < MaxBoundaryLevel; idx++)
+			{
+				if (CurrTemperature <= pTssiPlusBoundary[idx])
+					break; /* level range found */
+			}
+
+			/*
+				the index is the step we should increase,
+				idx = 0 means there is nothing to compensate
+			*/
+			*pCompensationLevel = TxAgcStep * (idx-1);
+			DBGPRINT(RT_DEBUG_TRACE,
+						("++ Tx Power, CurrTemperature=%d, TssiRef=%d, TxAgcStep=%d, step = +%d, , CompensationLevel = %d\n",
+				    		CurrTemperature, TssiRef, TxAgcStep, idx-1, *pCompensationLevel));
+		}
+		else
+		{
+			*pCompensationLevel = 0;
+			DBGPRINT(RT_DEBUG_TRACE,
+						("  Tx Power, CurrTemperature=%d, TssiRef=%d, TxAgcStep=%d, step = +%d\n",
+						CurrTemperature, TssiRef, TxAgcStep, 0));
+		}
+	}
+
+	return TRUE;
+}
+
+
+/* 5G-band temperature compensation specific for MT7610E EP */
+static VOID MT76x0ATE_TemperatureCompensation(
+        IN PRTMP_ADAPTER pAd) 
+{
+	ATE_INFO* pATEInfo = &(pAd->ate);
+	PUCHAR pTssiMinusBoundary, pTssiPlusBoundary;
+	UINT32 MacValue;
+	INT32 base_power;
+	USHORT e2p_value = 0;
+	BOOLEAN bResetTssiInfo = TRUE;
+	CHAR delta_pwr = 0;
+	
+	/* MT7630 is 2.4G band only */
+	if (IS_MT7630(pAd))
+	{
+		DBGPRINT(RT_DEBUG_ERROR, ("error - 7630: Channel = %d\n", pATEInfo->Channel));
+		return;
+	}
+
+	if (IS_MT7610(pAd) || IS_MT7650(pAd))
+	{
+		if (pATEInfo->Channel <= 14)
+		{
+			DBGPRINT(RT_DEBUG_ERROR, 
+					("%s(): Current channel setting is NOT 5G band! \n", __FUNCTION__));
+			return;
+		}
+	}
+
+	/* TX 5G power compensation channel boundary index */
+	DBGPRINT(RT_DEBUG_TRACE, 
+			("%s(): channel boundary index = %u\n", __FUNCTION__, pAd->ChBndryIdx));
+
+	if (pATEInfo->Channel <= pAd->ChBndryIdx)
+	{
+		/* use table of 5G group 1 */
+		pTssiMinusBoundary = pAd->TssiMinusBoundaryA[0];
+		pTssiPlusBoundary = pAd->TssiPlusBoundaryA[0];
+	}
+	else
+	{
+		/* use table of 5G group 2 */
+		pTssiMinusBoundary = pAd->TssiMinusBoundaryA[1];
+		pTssiPlusBoundary = pAd->TssiPlusBoundaryA[1];
+	}
+
+	/* show base power from 0x13B0 bit[5:0] */
+	RTMP_IO_READ32(pAd, TX_ALC_CFG_0, &MacValue);
+	base_power = (MacValue & 0x0000003F);
+	DBGPRINT(RT_DEBUG_TRACE, ("%s(): base_power is %d\n", __FUNCTION__, base_power));
+
+	if (MT76x0_AsicGetTssiReport(pAd,
+								bResetTssiInfo,
+								&pAd->CurrTemperature) == TRUE)
+	{
+		if (MT76x0ATE_GetTemperatureCompensationLevel(
+							pAd,
+							pAd->bAutoTxAgcA,
+							pAd->TssiRefA,
+							pTssiMinusBoundary,
+							pTssiPlusBoundary,
+							8, /* no. of boundary levels */
+							2, /* pAd->TxAgcStepA, */
+							pAd->CurrTemperature,
+							&pAd->TxAgcCompensateA) == TRUE)
+		{
+			/* adjust compensation value by MP temperature readings(i.e., e2p[77h]) */
+			delta_pwr = pAd->TxAgcCompensateA - pAd->mp_delta_pwr;
+
+			DBGPRINT(RT_DEBUG_ERROR, ("%s(): base_power is %d\n", __FUNCTION__, pAd->TxAgcCompensateA));
+			/* 8-bit representation ==> 6-bit representation (2's complement) */
+			delta_pwr = (delta_pwr & 0x80) ? \
+							((delta_pwr & 0x1F) | 0x20) : (delta_pwr & 0x3F);						
+
+			/*
+				write compensation value into TX_ALC_CFG_1, 
+				delta_pwr (unit: 0.5dB) will be compensated by TX_ALC_CFG_1
+			*/     
+			RTMP_IO_READ32(pAd, TX_ALC_CFG_1, &MacValue); /* MAC 0x13B4 */
+			MacValue = (MacValue & (~0x3F)) | delta_pwr;
+			RTMP_IO_WRITE32(pAd, TX_ALC_CFG_1, MacValue);
+
+			DBGPRINT(RT_DEBUG_TRACE, 
+						("%s - delta_pwr = %d, TssiCalibratedOffset = %d, TssiMpOffset = %d, Mac 0x13B4 = 0x%08x, TxAgcCompensateA = %d\n",
+						__FUNCTION__,
+						(delta_pwr & 0x20) ? (delta_pwr | 0x0C) : (delta_pwr),
+						pAd->TssiCalibratedOffset/* reference temperature(i.e., e2p[D1h]) */,
+						pAd->mp_delta_pwr,
+						MacValue, pAd->TxAgcCompensateA));	
+		}
+		else
+		{
+			DBGPRINT(RT_DEBUG_ERROR, 
+						("%s(): Failed to get a compensation level!\n",
+						__FUNCTION__)); 
+		}
+	}
+}        
+#endif /* RTMP_TEMPERATURE_COMPENSATION */
+
+
 static VOID MT76x0ATE_AsicExtraPowerOverMAC(
 	IN PRTMP_ADAPTER pAd)
 {
@@ -1549,8 +1673,6 @@ VOID MT76x0ATE_VCO_CalibrationMode3(
 }
 
 
-/* This function vesion is specific for Cameo */
-/* It must be replaced by formal one for other customers */
 VOID MT76x0ATE_Calibration(
 	IN RTMP_ADAPTER *pAd,
 	IN UCHAR Channel,
@@ -1558,6 +1680,12 @@ VOID MT76x0ATE_Calibration(
 	IN BOOLEAN bFullCal)
 {
 	UINT32 MacReg = 0, reg_val = 0, reg_tx_alc = 0;
+	UINT32 param, _param0, _param1, _param2;
+#ifdef RTMP_FLASH_SUPPORT
+	UINT32 bCalFlash = pAd->ate.bSaveFlashEnabled;
+#else
+	UINT32 bCalFlash = FALSE;
+#endif /* RTMP_FLASH_SUPPORT */
 
 	/* MT7610 is 5G band only */
 	if (IS_MT7610(pAd))
@@ -1604,7 +1732,7 @@ VOID MT76x0ATE_Calibration(
 		*/
 		CHIP_CALIBRATION(pAd, R_CALIBRATION, 0x0);
 
-		MT76x0ATE_VCO_CalibrationMode3(pAd);
+		MT76x0_VCO_CalibrationMode3(pAd, Channel);
 		RtmpusecDelay(1);
 	}
 
@@ -1627,6 +1755,27 @@ VOID MT76x0ATE_Calibration(
 	*/
 	if (bFullCal)
 	{
+		if (Channel > 14)
+		{
+			_param0 = (1 /* 5G + External PA */) ? 1 : 2;
+			_param1 = 1; /* 0: G-Band, 1: A-Band */
+			
+			if (Channel < 100)
+				_param2 = (bCalFlash == TRUE) ? 0x7 : 0x0;
+			else if (Channel < 140)
+				_param2 = (bCalFlash == TRUE) ? 0x8 : 0x0;
+			else
+				_param2 = (bCalFlash == TRUE) ? 0x9 : 0x0;
+		}
+		else
+		{
+			// TODO: 2.4G Need to check parameter [31:16]
+			_param0 = 0; /* 2G */
+			_param1 = 0; /* 0: G-Band, 1: A-Band */
+			_param2 = (bCalFlash == TRUE) ? 0x6 : 0x0;
+		}
+		param = _param0 | (_param2 << 8); /* for LC Calibration */
+
 		/*
 			1. RXDC Calibration parameter
 				0:Back Ground Disable
@@ -1651,13 +1800,8 @@ VOID MT76x0ATE_Calibration(
 					8: A-Band (Mid) Restore Calibration
 					9: A-Band (High) Restore Calibration
 		*/
-		if (Channel > 14)
-		{
-			// TODO: check PA setting from EEPROM @20121016
-			CHIP_CALIBRATION(pAd, LC_CALIBRATION, 0x1);
-		}
-		else
-			CHIP_CALIBRATION(pAd, LC_CALIBRATION, 0x0);
+		// TODO: If 5G, check PA setting from EEPROM @20121016
+		CHIP_CALIBRATION(pAd, LC_CALIBRATION, param);
 
 		/*
 			3,4. BW-Calibration
@@ -1676,6 +1820,8 @@ VOID MT76x0ATE_Calibration(
 					9: A-Band (High) Restore Calibration
 		*/
 
+		param = _param1 | (_param2 << 8);
+
 		/*
 			5. RF LOFT-Calibration parameter
 				Bit[0:7] (0:G-Band, 1: A-Band)
@@ -1692,12 +1838,7 @@ VOID MT76x0ATE_Calibration(
 					9: A-Band (High) Restore Calibration
 
 		*/
-		if (Channel > 14)
-		{
-			CHIP_CALIBRATION(pAd, LOFT_CALIBRATION, 0x1);
-		}
-		else
-			CHIP_CALIBRATION(pAd, LOFT_CALIBRATION, 0x0);
+		CHIP_CALIBRATION(pAd, LOFT_CALIBRATION, param);
 
 		/*
 			6. TXIQ-Calibration parameter
@@ -1714,14 +1855,8 @@ VOID MT76x0ATE_Calibration(
 					8: A-Band (Mid) Restore Calibration
 					9: A-Band (High) Restore Calibration
 		*/
-		if (Channel > 14)
-		{
-			CHIP_CALIBRATION(pAd, TXIQ_CALIBRATION, 0x1);
-		}
-		else
-		{
-			CHIP_CALIBRATION(pAd, TXIQ_CALIBRATION, 0x0);
-		}
+		CHIP_CALIBRATION(pAd, TXIQ_CALIBRATION, param);
+
 		/*			
 			7. TX Group-Delay Calibation parameter
 				Bit[0:7] (0:G-Band, 1: A-Band)
@@ -1737,14 +1872,8 @@ VOID MT76x0ATE_Calibration(
 					8: A-Band (Mid) Restore Calibration
 					9: A-Band (High) Restore Calibration
 		*/
-		if (Channel > 14)
-		{
-			CHIP_CALIBRATION(pAd, TX_GROUP_DELAY_CALIBRATION, 0x1);
-		}
-		else
-		{
-			CHIP_CALIBRATION(pAd, TX_GROUP_DELAY_CALIBRATION, 0x0);
-		}
+		CHIP_CALIBRATION(pAd, TX_GROUP_DELAY_CALIBRATION, param);
+
 		/*
 			8. RXIQ-Calibration parameter
 				Bit[0:7] (0:G-Band, 1: A-Band)
@@ -1774,21 +1903,16 @@ VOID MT76x0ATE_Calibration(
 					8: A-Band (Mid) Restore Calibration
 					9: A-Band (High) Restore Calibration
 		*/
-		if (Channel > 14)
-		{
-			CHIP_CALIBRATION(pAd, RXIQ_CALIBRATION, 0x1);
-			CHIP_CALIBRATION(pAd, RX_GROUP_DELAY_CALIBRATION, 0x1);
-		}
-		else
-		{
-			CHIP_CALIBRATION(pAd, RXIQ_CALIBRATION, 0x0);
-			CHIP_CALIBRATION(pAd, RX_GROUP_DELAY_CALIBRATION, 0x0);
-		}
+		CHIP_CALIBRATION(pAd, RXIQ_CALIBRATION, param);
+		CHIP_CALIBRATION(pAd, RX_GROUP_DELAY_CALIBRATION, param);			
+
 		/* 
 			10. TX 2G DPD - Only 2.4G needs to do DPD Calibration. 
 		*/
 		if (Channel <= 14)
+		{
 			CHIP_CALIBRATION(pAd, DPD_CALIBRATION, 0x0);
+		}
 	}
 	else
 	{
@@ -1806,8 +1930,176 @@ VOID MT76x0ATE_Calibration(
 	RTMP_IO_WRITE32(pAd, TX_ALC_CFG_0, reg_tx_alc);
 }
 
+#ifdef RTMP_MAC_PCI
+#ifdef RTMP_FLASH_SUPPORT
+#define CR_COUNT (25) 
+#define BAND_GROUP (3) /* high, middle, low */
+#define CR_TOTAL_COUNT (CR_COUNT * BAND_GROUP)
+#define CR_FLASH_BASE_ADDR (0x200) /* == 512 */
+
+
+NDIS_STATUS MT76x0ATE_FlashWrite(
+	RTMP_ADAPTER *pAd, UCHAR *pData, ULONG offset, ULONG length)
+{
+	UINT32 cr_offset = offset; 
+	UINT32 len = length;
+
+	if (!pAd->chipCap.ee_inited)
+	{
+		return NDIS_STATUS_FAILURE;
+	}
+
+	RtmpFlashWrite(pData, (ULONG)cr_offset, (ULONG)len);
+
+	return NDIS_STATUS_SUCCESS;
+}
+
+
+NDIS_STATUS  MT76x0ATE_SaveFlashCR(
+    RTMP_ADAPTER *pAd, UINT32 level)
+{
+	/* parameters */
+	ATE_INFO *pATEInfo = &(pAd->ate);
+	UINT32 reg_val[CR_TOTAL_COUNT + 1];
+	UINT32 bbp_index = 0;
+	UINT32 bbp_value = 0;
+	UINT32 cr_flash_offset = RF_OFFSET+CR_FLASH_BASE_ADDR; 
+	UINT32 total_content_size = ((CR_TOTAL_COUNT + 1) * 4); /* 1: valid flag(reserved) */
+	UINT ch_idx = 0, cr_index = 0;
+	UCHAR cmdStr[32];
+	UCHAR ch[] = {155, 136, 42, 0};
+	UCHAR rf_value = 0;
+	UCHAR pos = 0;
+
+	NdisZeroMemory((UCHAR *)reg_val, sizeof(reg_val));
+
+#ifdef CONFIG_RT2880_ATE_CMD_NEW
+	Set_ATE_Proc(pAd, "ATESTART");
+#else
+	Set_ATE_Proc(pAd, "APSTOP");
+#endif /* CONFIG_RT2880_ATE_CMD_NEW */
+
+	/* only for debug */
+	/* write all CR as 0x00 in flash */	
+	if (level == 0)
+	{
+		if (MT76x0ATE_FlashWrite(pAd, (UCHAR *)reg_val, (ULONG)cr_flash_offset,
+				(ULONG)total_content_size) != NDIS_STATUS_SUCCESS)
+		{
+			return NDIS_STATUS_FAILURE;
+		}
+		return NDIS_STATUS_SUCCESS;
+	}
+
+	/* DW[0] is reserved */
+	reg_val[0] = 0xFFFFFFFF;
+	
+	for (ch_idx = 0; ch[ch_idx] != 0; ch_idx++)
+	{
+		/* set BW ? */
+		/* set frequency offset ? */
+		/* switch channel ? */
+		snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch[ch_idx]);
+		if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
+		{
+			return NDIS_STATUS_FAILURE;
+		}
+
+		ATEAsicSwitchChannel(pAd);
+		/* AsicLockChannel() is empty function so far in fact */
+		AsicLockChannel(pAd, pATEInfo->Channel);
+		RtmpOsMsDelay(5);
+		/* beginning position for each channel group */
+		pos = (CR_COUNT * ch_idx) + 1;
+
+		/* read A-band LC calibration results */
+		rlt_rf_read(pAd, RF_BANK0, RF_R39, &rf_value);
+		reg_val[pos] = (UINT32)rf_value;	
+		rlt_rf_read(pAd, RF_BANK6, RF_R24, &rf_value);
+		reg_val[pos+1] = (UINT32)rf_value;	
+		rlt_rf_read(pAd, RF_BANK6, RF_R39, &rf_value);
+		reg_val[pos+2] = (UINT32)rf_value;	
+		rlt_rf_read(pAd, RF_BANK6, RF_R17, &rf_value);
+		reg_val[pos+3] = (UINT32)rf_value;	
+		rlt_rf_read(pAd, RF_BANK6, RF_R58, &rf_value);
+		reg_val[pos+4] = (UINT32)rf_value;	
+		rlt_rf_read(pAd, RF_BANK6, RF_R59, &rf_value);
+		reg_val[pos+5] = (UINT32)rf_value;	
+
+		/* 
+			read the CR calibrated by TX group delay and TX IQ calibration
+		*/
+		RTMP_BBP_IO_READ32(pAd, CAL_R14, &bbp_value);
+		reg_val[pos+6] = bbp_value;
+
+		/* 
+			read 2 CRs calibrated by RX group delay
+			and RX IQ calibration
+		*/
+		RTMP_BBP_IO_READ32(pAd, CAL_R24, &bbp_value);
+		reg_val[pos+7] = bbp_value;
+		
+		RTMP_BBP_IO_READ32(pAd, CAL_R28, &bbp_value);
+		reg_val[pos+8] = bbp_value;
+		
+		/* read 16 CRs calibrated by LOFT calibration */
+		for (bbp_index = 0; bbp_index < 16; bbp_index++)
+		{
+			RTMP_BBP_IO_WRITE32(pAd, 0x2CF0, bbp_index);
+			RTMP_BBP_IO_READ32(pAd, 0x2CF4, &bbp_value);
+			reg_val[pos+9+bbp_index] = bbp_value;
+		}
+	}
+
+	/* write the buffer content to flash */	
+	if (level == 1)
+	{
+		if (MT76x0ATE_FlashWrite(pAd, (UCHAR *)reg_val, (ULONG)cr_flash_offset,
+				(ULONG)total_content_size) != NDIS_STATUS_SUCCESS)
+		{
+			return NDIS_STATUS_FAILURE;
+		}
+	}
+
+	/* only for debug */
+	/* not yet write the buffer content to flash */	
+	if (level == 2)
+	{
+		DBGPRINT(RT_DEBUG_OFF, ("================================\n"));
+
+		for (cr_index = 0; cr_index <= CR_TOTAL_COUNT; cr_index++)
+		{
+			if (cr_index==((CR_COUNT*0)+1))
+			{
+				DBGPRINT(RT_DEBUG_OFF, ("\nHigh channel CR:\n\n"));
+			}
+
+			if (cr_index==((CR_COUNT*1)+1))
+			{
+				DBGPRINT(RT_DEBUG_OFF, ("\nMiddle channel CR:\n\n"));
+			}
+
+			if (cr_index==((CR_COUNT*2)+1))
+			{
+				DBGPRINT(RT_DEBUG_OFF, ("\nLow channel CR:\n\n"));
+			}
+
+			DBGPRINT(RT_DEBUG_OFF, ("DW[%u]== 0x%08x\n", cr_index, reg_val[cr_index]));
+		}
+
+		DBGPRINT(RT_DEBUG_OFF, ("================================\n"));
+
+		RTDebugLevel = RT_DEBUG_TRACE;
+		hex_dump("content to save", (UCHAR *)reg_val, (UINT)total_content_size);
+		RTDebugLevel = RT_DEBUG_OFF;
+		DBGPRINT(RT_DEBUG_OFF, ("\nNote ! The content above is NOT saved to flash yet !\n"));
+	}
+
+	return NDIS_STATUS_SUCCESS;
+}
+#endif /* RTMP_FLASH_SUPPORT */
+#endif /* RTMP_MAC_PCI */
 
-#ifdef SINGLE_SKU_V2
 static VOID MT76x0ATE_CalculateTxpower(
 	IN  BOOLEAN bMinus,
 	IN  USHORT InputTxpower,
@@ -2038,7 +2330,60 @@ VOID MT76x0AteReadTxPwrPerRate(
 	
     DBGPRINT(RT_DEBUG_TRACE, ("%s: <--\n", __FUNCTION__));
 }
-#endif /* SINGLE_SKU_V2 */
+
+
+#ifdef RTMP_MAC_PCI
+#ifdef RTMP_EFUSE_SUPPORT
+VOID MT76x0AteReadBufferAndInitAsic(
+	IN RTMP_ADAPTER *pAd)
+{
+	USHORT ee_val = 0;
+	UINT32 reg_val = 0;
+
+	RT28xx_EEPROM_READ16(pAd, 0x22, ee_val);
+	DBGPRINT(RT_DEBUG_TRACE, ("%s: 0x22 = 0x%x\n", __FUNCTION__, ee_val));
+	RTMP_IO_READ32(pAd, CMB_CTRL, &reg_val);
+	reg_val &= 0xFFFF0000;
+	reg_val |= ee_val;
+	RTMP_IO_WRITE32(pAd, CMB_CTRL, reg_val);
+
+	RT28xx_EEPROM_READ16(pAd, 0x24, ee_val);
+	DBGPRINT(RT_DEBUG_TRACE, ("%s: 0x24 = 0x%x\n", __FUNCTION__, ee_val));
+	RTMP_IO_READ32(pAd, 0x104, &reg_val);
+	reg_val &= 0xFFFF0000;
+	reg_val |= ee_val;
+	RTMP_IO_WRITE32(pAd, 0x104, reg_val);
+
+	return;
+}
+#endif /* RTMP_EFUSE_SUPPORT */
+#endif /* RTMP_MAC_PCI */
+
+#ifdef SINGLE_SKU_V2
+static void mt76x0_ate_single_sku(IN PRTMP_ADAPTER	pAd, IN BOOLEAN value)
+{	
+	PATE_INFO pATEInfo = &(pAd->ate);
+
+	/* should use BBPCurrentBW = BW 20 for single sku in band edge channel */
+	if(pAd->ate.Channel == 1 || pAd->ate.Channel == 2 || pAd->ate.Channel == 10 || pAd->ate.Channel == 11)
+		pAd->CommonCfg.BBPCurrentBW = BW_20;
+	else
+		pAd->CommonCfg.BBPCurrentBW = pATEInfo->BBPCurrentBW_Backup;
+	
+	if (value > 0)
+	{
+		pATEInfo->bDoSingleSKU = TRUE;			
+		/* force reconfiguration of the channel , to apply single sku value */
+		pATEInfo->PreviousChannel = 0;
+		DBGPRINT(RT_DEBUG_ERROR, ("ATESINGLESKU = TRUE , enabled single sku in ATE! Force switch channel to calculate single sku\n"));
+	}
+	else
+	{
+			}	
+	
+}
+#endif
+
 
 #ifdef RTMP_MAC_PCI
 struct _ATE_CHIP_STRUCT RALINK6590 =
@@ -2052,15 +2397,19 @@ struct _ATE_CHIP_STRUCT RALINK6590 =
 	.AsicSetTxRxPath = NULL,
 #ifdef MT76x0_TSSI_CAL_COMPENSATION
 	.AdjustTxPower = MT76x0ATETssiCompensation,
-#else
-	.AdjustTxPower = NULL,
 #endif /* MT76x0_TSSI_CAL_COMPENSATION */
+#ifdef RTMP_TEMPERATURE_COMPENSATION
+	.AdjustTxPower = MT76x0ATE_TemperatureCompensation,
+#endif /* RTMP_TEMPERATURE_COMPENSATION */
 	.AsicExtraPowerOverMAC = MT76x0ATE_AsicExtraPowerOverMAC,
 	.TemperCompensation = NULL,
 	
 	/* command handlers */
 	.Set_BW_Proc = MT76x0_Set_ATE_TX_BW_Proc,
 	.Set_FREQ_OFFSET_Proc = MT76x0_Set_ATE_TX_FREQ_OFFSET_Proc,
+#ifdef SINGLE_SKU_V2
+	.do_ATE_single_sku = mt76x0_ate_single_sku,
+#endif
 
 	/* variables */
 	.maxTxPwrCnt = 5,
diff --git a/mt76x2/ate/chips/rt85592_ate.c b/mt76x2/ate/chips/rt85592_ate.c
old mode 100644
new mode 100755
diff --git a/mt76x2/ate/common/ate_pci.c b/mt76x2/ate/common/ate_pci.c
old mode 100644
new mode 100755
index 25d7056..5db985e
--- a/mt76x2/ate/common/ate_pci.c
+++ b/mt76x2/ate/common/ate_pci.c
@@ -150,7 +150,9 @@ VOID ATEWriteTxWI(
 	TXWI_STRUC TxWI, *pTxWI;
 	UINT8 TXWISize = pAd->chipCap.TXWISize;
 	UCHAR bw;
+#ifdef SINGLE_SKU_V2	
 	PATE_INFO pATEInfo = &(pAd->ate);
+#endif /* SINGLE_SKU_V2 */
 
 	/* If CCK or OFDM, BW must be 20 */
 	bw = (pTransmit->field.MODE <= MODE_OFDM) ? (BW_20) : (pTransmit->field.BW);
@@ -566,7 +568,12 @@ INT ATESetUpFrame(
 		/* build Tx descriptor */
 		pTxD->SDPtr0 = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 		pTxD->SDLen0 = TXWISize + pATEInfo->HLen;
+#ifndef RT_SECURE_DMA
 		pTxD->SDPtr1 = AllocPa;
+#else
+		NdisMoveMemory(pAd->TxSecureDMA[QID_AC_BE].AllocVa + (TxIdx * 4096), AllocVa, GET_OS_PKT_LEN(pPacket));
+		pTxD->SDPtr1 = pAd->TxSecureDMA[QID_AC_BE].AllocPa + (TxIdx * 4096);
+#endif
 		pTxD->SDLen1 = GET_OS_PKT_LEN(pPacket);
 		pTxD->LastSec0 = (pTxD->SDLen1 == 0) ? 1 : 0;
 		pTxD->LastSec1 = 1;
@@ -592,7 +599,12 @@ INT ATESetUpFrame(
 		/* build Tx descriptor */
 		pTxD->SDPtr0 = RTMP_GetPhysicalAddressLow (pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 		pTxD->SDLen0 = TXWISize + pATEInfo->HLen /* LENGTH_802_11 */;
+#ifndef RT_SECURE_DMA
 		pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, &txblk, 0, 1, RTMP_PCI_DMA_TODEVICE);
+#else
+		NdisMoveMemory(pAd->TxSecureDMA[QID_AC_BE].AllocVa + (TxIdx * 4096), AllocVa, GET_OS_PKT_LEN(pPacket));
+		pTxD->SDPtr1 = pAd->TxSecureDMA[QID_AC_BE].AllocPa + (TxIdx * 4096);
+#endif
 		pTxD->SDLen1 = GET_OS_PKT_LEN(pPacket);
 		pTxD->LastSec0 = (pTxD->SDLen1 == 0) ? 1 : 0;
 		pTxD->LastSec1 = 1;
@@ -901,7 +913,12 @@ INT ATESetUpNDPAFrame(
 		/* build Tx descriptor */
 		pTxD->SDPtr0 = RTMP_GetPhysicalAddressLow(pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 		pTxD->SDLen0 = TXWISize + pATEInfo->HLen;
+#ifndef RT_SECURE_DMA
 		pTxD->SDPtr1 = AllocPa;
+#else
+		NdisMoveMemory(pAd->TxSecureDMA[QID_AC_BE].AllocVa + (TxIdx * 4096), AllocVa, GET_OS_PKT_LEN(pPacket));
+		pTxD->SDPtr1 = pAd->TxSecureDMA[QID_AC_BE].AllocPa + (TxIdx * 4096);
+#endif
 		pTxD->SDLen1 = GET_OS_PKT_LEN(pPacket);
 		pTxD->LastSec0 = (pTxD->SDLen1 == 0) ? 1 : 0;
 		pTxD->LastSec1 = 1;
@@ -927,7 +944,12 @@ INT ATESetUpNDPAFrame(
 		/* build Tx descriptor */
 		pTxD->SDPtr0 = RTMP_GetPhysicalAddressLow (pTxRing->Cell[TxIdx].DmaBuf.AllocPa);
 		pTxD->SDLen0 = TXWISize + pATEInfo->HLen /* LENGTH_802_11 */;
+#ifndef RT_SECURE_DMA
 		pTxD->SDPtr1 = PCI_MAP_SINGLE(pAd, &txblk, 0, 1, RTMP_PCI_DMA_TODEVICE);
+#else
+		NdisMoveMemory(pAd->TxSecureDMA[QID_AC_BE].AllocVa + (TxIdx * 4096), AllocVa, GET_OS_PKT_LEN(pPacket));
+		pTxD->SDPtr1 = pAd->TxSecureDMA[QID_AC_BE].AllocPa + (TxIdx * 4096);
+#endif
 		pTxD->SDLen1 = GET_OS_PKT_LEN(pPacket);
 		pTxD->LastSec0 = (pTxD->SDLen1 == 0) ? 1 : 0;
 		pTxD->LastSec1 = 1;
diff --git a/mt76x2/ate/common/rt_ate.c b/mt76x2/ate/common/rt_ate.c
old mode 100644
new mode 100755
index fa22e2a..df35cfc
--- a/mt76x2/ate/common/rt_ate.c
+++ b/mt76x2/ate/common/rt_ate.c
@@ -260,6 +260,7 @@ CHAR ATEConvertToRssi(
 				return (Rssi + pAd->ARssiOffset[RssiNumber] - extra_gain);
 			else
 				return (Rssi + pAd->BGRssiOffset[RssiNumber] - extra_gain);
+			
 		} else
 			return (Rssi - LNAGain - RssiOffset);
 	}
@@ -646,7 +647,7 @@ static VOID SetJapanFilter(RTMP_ADAPTER *pAd)
 VOID ATEDisableAsicProtect(
 	IN		PRTMP_ADAPTER	pAd)
 {
-	PROT_CFG_STRUC	ProtCfg, ProtCfg4;
+	PROT_CFG_STRUC	ProtCfg;
 	UINT32 Protect[6];
 	USHORT			offset;
 	UCHAR			step;
@@ -660,7 +661,6 @@ VOID ATEDisableAsicProtect(
 
 	/* Initial common protection settings */
 	RTMPZeroMemory(Protect, sizeof(Protect));
-	ProtCfg4.word = 0;
 	ProtCfg.word = 0;
 	ProtCfg.field.TxopAllowGF40 = 1;
 	ProtCfg.field.TxopAllowGF20 = 1;
@@ -941,9 +941,12 @@ static NDIS_STATUS ATESTART(
 	RTMP_IO_READ32(pAd, 0x1608, &mac_val);
 	mac_val &= (~0x2);
 	RTMP_IO_WRITE32(pAd, 0x1608, mac_val);
-#ifdef DOT11N_DRAFT3
+
+	DBGPRINT(RT_DEBUG_ERROR,("%s: Clear fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS\n", __FUNCTION__));	
+	RTMP_CLEAR_FLAG(pAd, fRTMP_ADAPTER_BSS_SCAN_IN_PROGRESS);
+#ifdef DOT11N_DRAFT3
 	Set_HT_BssCoex_Proc(pAd,"0"); //Disable 20/40 coexistense
+#endif /* DOT11N_DRAFT3 */
-#endif
 	AsicBBPAdjust(pAd);
 	/* Disable Protection */
 	AsicUpdateProtect(pAd, 0,  (ALLN_SETPROTECT|CCKSETPROTECT|OFDMSETPROTECT), TRUE, FALSE);
@@ -1574,7 +1575,7 @@ static NDIS_STATUS ATESTOP(
 			{
 				SysRegValue |= 0x100000;
 				RTMP_SYS_IO_WRITE32(0xb0000060, SysRegValue);
-				DBGPRINT(RT_DEBUG_ERROR,("Change as GPIO Mode(0x%lx)\n", SysRegValue));
+				DBGPRINT(RT_DEBUG_ERROR,("Change as GPIO Mode(0x%x)\n", SysRegValue));
 			}
 		}
 
@@ -1631,7 +1632,7 @@ static NDIS_STATUS ATESTOP(
 			{
 				SysRegValue &= (~0x100000);
 				RTMP_SYS_IO_WRITE32(0xb0000060, SysRegValue);
-				DBGPRINT(RT_DEBUG_ERROR,("Change as Normal Mode(0x%lx)\n", SysRegValue));
+				DBGPRINT(RT_DEBUG_ERROR,("Change as Normal Mode(0x%x)\n", SysRegValue));
 			}
 	}
 
@@ -2397,8 +2398,8 @@ static NDIS_STATUS TXFRAME(
 	/* ATE tool for CE BF gain certification, sounding mode and TxBf flag must be modified */
 	if (pAd->ceBfCertificationFlg == TRUE)
 	{
-		pAd->soundingMode = pATEInfo->txSoundingMode;
-                pAd->txLengthBackup = pATEInfo->TxLength;
+		pAd->soundingMode   = pATEInfo->txSoundingMode;
+        pAd->txLengthBackup = pATEInfo->TxLength;
 	}
 #endif 
 	for (ring_index = 0; (ring_index < TX_RING_SIZE-1) && (ring_index < pATEInfo->TxCount); ring_index++)
@@ -2446,7 +2447,7 @@ static NDIS_STATUS TXFRAME(
 		/* ATE tool for CE BF gain certification, sounding mode and TxBf flag must be modified */
 		if (pAd->ceBfCertificationFlg == TRUE)
 		{
-        		pATEInfo->txSoundingMode = 0;
+        	pATEInfo->txSoundingMode = 0;
 		}
 
 		if (pATEInfo->TxWI.TXWI_N.PHYMODE == MODE_VHT && pATEInfo->bTxBF == TRUE && pATEInfo->txSoundingMode != 0)
@@ -2456,8 +2457,8 @@ static NDIS_STATUS TXFRAME(
 		}
 		else
 		{
-		if (ATESetUpFrame(pAd, TxIdx) != 0)
-			return NDIS_STATUS_FAILURE;
+		    if (ATESetUpFrame(pAd, TxIdx) != 0)
+			    return NDIS_STATUS_FAILURE;
 		}
 #else
 		if (ATESetUpFrame(pAd, TxIdx) != 0)
@@ -2472,7 +2473,7 @@ static NDIS_STATUS TXFRAME(
 	}
 	else
 	{
-	ATESetUpFrame(pAd, pTxRing->TxCpuIdx);
+	    ATESetUpFrame(pAd, pTxRing->TxCpuIdx);
 	}
 
 	/* ATE tool for CE BF gain certification, sounding mode and TxBf flag must be modified */
@@ -2631,8 +2632,8 @@ if ( IS_MT76x2(pAd) )
 		value32 = (pATEInfo->TxWI.TXWI_N.iTxBF == TRUE) ? (value32 | 0x120) : value32;
 		RTMP_IO_WRITE32(pAd, PFMU_R1, value32);
 	}
-#endif
-#endif
+#endif /*TXBF_SUPPORT*/
+#endif /*MT76x2*/
 
 	DBGPRINT(RT_DEBUG_TRACE, ("ATE : <=== %s\n", __FUNCTION__));
 	return Status;
@@ -2678,7 +2679,6 @@ static NDIS_STATUS RXFRAME(
 	/* Disable Tx of MAC block. */
 	ATE_MAC_TX_DISABLE(pAd, MAC_SYS_CTRL, &MacData);
 
-
 	/* Enable Rx of MAC block. */
 	ATE_MAC_RX_ENABLE(pAd, MAC_SYS_CTRL, &MacData);
 
@@ -2741,7 +2741,9 @@ static NDIS_STATUS	ATECmdHandler(
 	ATE_INFO *pATEInfo = &(pAd->ate);
 	NDIS_STATUS		Status = NDIS_STATUS_SUCCESS;
 	BOOLEAN bNeedTxRx = FALSE;
-	UINT value32;
+#ifdef TXBF_SUPPORT
+    UINT32 value32;
+#endif
 
 	DBGPRINT(RT_DEBUG_TRACE, ("===> %s\n", __FUNCTION__));
 
@@ -2852,22 +2854,32 @@ static NDIS_STATUS	ATECmdHandler(
 			RTMP_IO_READ32(pAd, PFMU_R1, &value32);
 			value32 |= 0x330;
 			RTMP_IO_WRITE32(pAd, PFMU_R1, value32);
+			
+			//iBF divider calibration
+            pAd->chipOps.fITxBfDividerCalibration(pAd, 10, 0, pAd->divPhaseBackup);  
 		}
-        //iBF divider calibration
-        pAd->chipOps.fITxBfDividerCalibration(pAd, 10, 0, pAd->divPhaseBackup);  
 #endif /* TXBF_SUPPORT */
 #endif /* MT76x2 */
+
 		Status = TXFRAME(pAd);
 	}
 	else if (!strcmp(arg, "TXFRAME_IBF"))    // flow for iBF verification, skip switch channel
-	{		
-        //ATEAsicSwitchChannel(pAd); 
-		RtmpOsMsDelay(5);
-		
+	{				
 #ifdef TXBF_SUPPORT
 #ifdef MT76x2
-         //iBF divider calibration
-         pAd->chipOps.fITxBfDividerCalibration(pAd, 10, 0, pAd->divPhaseBackup);
+        if (IS_MT76x2(pAd))
+        {
+            /* Enable TxBf profile update */
+            RTMP_IO_READ32(pAd, PFMU_R1, &value32);
+            value32 |= 0x330;
+            RTMP_IO_WRITE32(pAd, PFMU_R1, value32);
+        }
+        //iBF divider calibration , and write compensation value to TXBF_R13
+        pAd->chipOps.fITxBfDividerCalibration(pAd, 3, 0, pAd->divPhaseBackup);
+
+       	/* Enable TX Phase Compensation */
+     	RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+	    RTMP_IO_WRITE32(pAd, TXBE_R12, value32 | 0x08); 
 #endif /* MT76x2 */		
 #endif /* TXBF_SUPPORT */
 
@@ -2875,14 +2887,10 @@ static NDIS_STATUS	ATECmdHandler(
 	}
 	else if (!strcmp(arg, "TXFRAMESOUNDING")) 
 	{
-		ATEAsicSwitchChannel(pAd);
-		/* AsicLockChannel() is empty function so far in fact */
-		AsicLockChannel(pAd, pATEInfo->Channel);
-		RtmpOsMsDelay(5);
 		
 #ifdef TXBF_SUPPORT
 		pAd->ceBfCertificationFlg = TRUE;
-                pAd->soundingPacketDone = 0;
+        pAd->soundingPacketDone = 0;
 		if (IS_MT76x2(pAd))
 		{
 			/* Enable TxBf profile update */
@@ -2893,7 +2901,7 @@ static NDIS_STATUS	ATECmdHandler(
 #endif /* TXBF_SUPPORT */
 
 		Status = TXFRAME(pAd);
-	}
+    }
 	else if (!strcmp(arg, "RXFRAME")) 
 	{
 #ifdef RT6352
@@ -2911,6 +2919,13 @@ static NDIS_STATUS	ATECmdHandler(
 			AsicLockChannel(pAd, pATEInfo->Channel);
 			RtmpusecDelay(5);
 		}
+
+#if defined(MT76x2) && defined(TXBF_SUPPORT)
+        /* Disable FOE Correct */
+        RTMP_IO_READ32(pAd, RXO_R16, &value32);
+        RTMP_IO_WRITE32(pAd, RXO_R16, value32 & (~BIT24));
+#endif /* MT76x2 && TXBF_SUPPORT */
+
 		Status = RXFRAME(pAd);
 	}
 	else if (!strcmp(arg, "TXAPPLY")) 
@@ -3289,6 +3304,11 @@ INT	Set_ATE_INIT_CHAN_Proc(
 		{
 			pATEInfo->TxPower0 = pAd->TxPower[index].Power;
 			pATEInfo->TxPower1 = pAd->TxPower[index].Power2;
+#ifdef TXBF_SUPPORT
+			pATEInfo->TxPower0 = 10;
+			pATEInfo->TxPower1 = 10;
+#endif /*TXBF_SUPPORT*/
+            DBGPRINT(RT_DEBUG_TRACE, ("TxPower0=%d ,TxPower1=%d\n", pATEInfo->TxPower0,pATEInfo->TxPower1));
 #ifdef DOT11N_SS3_SUPPORT
 			if (IS_RT2883(pAd) || IS_RT3593(pAd) || IS_RT3883(pAd))
 				pATEInfo->TxPower2 = pAd->TxPower[index].Power3;
@@ -3565,7 +3585,7 @@ INT	Set_ATE_TX_Antenna_Proc(
 		pATEInfo->TxAntennaSel = value;
 		pATEInfo->PreviousChannel = 0;
 	}
-	
+
 	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_Antenna_Proc (Antenna = %d)\n", pATEInfo->TxAntennaSel));
 	DBGPRINT(RT_DEBUG_TRACE, ("Ralink: Set_ATE_TX_Antenna_Proc Success\n"));
 
@@ -3578,6 +3598,15 @@ INT	Set_ATE_TX_Antenna_Proc(
 	if (IS_MT76x2(pAd))
 	ATEAsicSetTxRxPath(pAd);
 #endif /* MT76x2 */
+#ifdef RT6352
+	if (IS_RT6352(pAd))
+	{
+		if (pATEInfo->bTestTimeReduction == FALSE)
+		{
+			ATEAsicSwitchChannel(pAd);
+		}
+	}
+#endif /* RT6352 */
 #ifdef CONFIG_AP_SUPPORT
 #endif /* CONFIG_AP_SUPPORT */
 	
@@ -3781,7 +3810,6 @@ INT Set_ATE_AUTO_RESPONDER_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING 		arg)
 {
-	PATE_INFO pATEInfo = &(pAd->ate);
 	INT auto_respond = simple_strtol(arg, 0, 10);
 	UINT32 MacValue;
 
@@ -4188,7 +4216,7 @@ INT	Set_ATE_TX_MODE_Proc(
 	}
 #endif /* RT3350 */
 
-	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_MODE_Proc (TxMode = %d)\n", phy_mode));
+	DBGPRINT(RT_DEBUG_TRACE, ("Set_ATE_TX_MODE_Proc (TxMode = %d, bw = %d)\n", phy_mode, bw));
 	DBGPRINT(RT_DEBUG_TRACE, ("Ralink: Set_ATE_TX_MODE_Proc Success\n"));
 
 #ifdef CONFIG_AP_SUPPORT
@@ -4847,6 +4875,119 @@ INT	Set_ATE_TXSOUNDING_Proc(
 	return TRUE;
 }
 
+/* 
+==========================================================================
+    Description:
+	get channel index of iBF channel table 
+
+    Input:
+     - channel 
+     - mode : 0- group center channel table
+              1 - iBF calibration all channel table
+
+    Return:
+	-1 , if not found in iBF channel table 
+	index , if found in iBF channel table 
+
+    Note: 
+==========================================================================
+*/
+
+UCHAR iBFCenterCHTbl[5]   = {44, 60, 108, 132, 157};
+UCHAR iBFCHTbl_new[13]    = {36, 44, 52, 60, 100, 108, 116, 120, 132, 140, 149, 157, 165};
+UCHAR iBFCHgroupBound[10] = {36, 48, 52, 64, 100, 118, 120, 144, 149, 165};
+
+INT ate_txbf_get_chan_idx(
+    IN RTMP_ADAPTER *pAd,
+	IN UCHAR channel,
+	IN UCHAR mode)
+{
+    INT i,chanIdx = -1;
+    if (mode ==0)
+    {
+        for (i=0; i<sizeof(iBFCenterCHTbl); i++)
+	    {
+            if (channel == iBFCenterCHTbl[i])
+                chanIdx = i;   
+        }
+	}
+    else
+    {
+        for (i=0; i<sizeof(iBFCHTbl_new); i++)
+	    {
+            if (channel == iBFCHTbl_new[i])
+                chanIdx = i;   
+        }
+    }    
+	return chanIdx;	    
+}
+
+/* 
+==========================================================================
+    Description:
+	get index of channel group  
+		
+    Input:
+     - channel 
+
+    Return:	
+	index of channel group  
+
+    Note: 
+ ==========================================================================
+*/
+INT ate_txbf_chan_group_base_idx(
+    IN RTMP_ADAPTER *pAd,
+	IN UCHAR channel)
+{
+     INT baseIdx,i;
+     baseIdx = -1;  
+     for (i=0; i<(sizeof(iBFCHgroupBound)/2); i++)
+     { 
+         if ((channel >= iBFCHgroupBound[i*2]) && (channel <= iBFCHgroupBound[i*2+1]))
+             baseIdx = i;   
+     }
+
+    DBGPRINT(RT_DEBUG_TRACE,("baseIdx=%d\n",baseIdx));
+
+    return baseIdx;
+}
+/*
+==========================================================================
+    Description:
+	Sanity check for the channel of Implicit TxBF calibration.
+
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+
+    Note: 
+	1. This sanity check function only work for Implicit TxBF calibration.
+	2. Currently supported channels are:         
+        	1, 14, 36, 44, 52, 60, 100, 108, 116, 120, 132, 140, 149, 157, 165 for 11ac
+==========================================================================
+*/
+static BOOLEAN rtmp_ate_txbf_cal_valid_ch_new(
+	IN RTMP_ADAPTER *pAd,
+	IN UCHAR channel)
+{
+	BOOLEAN bValidCh;
+    UCHAR i;
+
+    bValidCh = FALSE;
+
+    if (channel == 0)
+        bValidCh = TRUE;
+
+    for (i=0 ; i< sizeof(iBFCHTbl_new); i++)
+	{
+        if (channel == iBFCHTbl_new[i])            
+            bValidCh = TRUE;
+    }
+
+
+	return bValidCh;	
+		}
+
 
 /* 
 ==========================================================================
@@ -4908,6 +5049,192 @@ static BOOLEAN rtmp_ate_txbf_cal_valid_ch(
 	return bValidCh;	
 }
 
+/* 
+==========================================================================
+    Description:
+      In calibration mode: 
+       -If the channel is a group center channel, enable auto K tank code
+       -If the channel is not a group center channel, set fixed tank code from group center channel 
+      In run time mode : 
+       -Set fixed tank code from group center channel       
+     
+     Return:
+     TRUE if all parameters are OK, FALSE otherwise
+ 
+     Note:   
+ ==========================================================================
+ */
+BOOLEAN rtmp_ate_txbf_fix_tank_code(
+         IN RTMP_ADAPTER *pAd,
+         IN UCHAR channel,
+         IN UCHAR CalibMode)
+{
+     INT    groupIdx, centrChanIdx;
+     UINT32 rf_val;
+     UINT   value,rptTank,lcTank0,lcTank1;
+     ITXBF_TANK_PARAMS tankParams;
+     BOOLEAN efuseStat;
+       
+     efuseStat = ITxBFGetEEPROM(pAd, 0, 0, 0, &tankParams);
+     centrChanIdx = ate_txbf_get_chan_idx(pAd, channel, 0);
+
+     DBGPRINT(RT_DEBUG_TRACE, ("######## CalibMode=%d ,efuseStat = %d,centrChanIdx = %d\n", CalibMode,efuseStat,centrChanIdx ));
+
+     if ((CalibMode == 0) && (efuseStat == TRUE))
+     {
+ 
+         DBGPRINT(RT_DEBUG_TRACE, ("######## (1) set Low-Q mode, and manual REPA-I ########\n"));
+         set_rf_bit(pAd, "1-150-12:12-0"); //low-Q mode		
+         set_rf_bit(pAd, "1-308-29:29-1"); //manaul REPA_I 
+         set_rf_bit(pAd, "1-320-23:20-c"); //manaul REPA_I
+
+         //enable manual tank code
+         DBGPRINT(RT_DEBUG_TRACE, ("######## enable manual tank code  ########\n"));
+         set_rf_bit(pAd, "1-308-28:28-1");
+         set_rf_bit(pAd, "1-2a8-24:24-1");
+         set_rf_bit(pAd, "0-2a8-24:24-1");
+
+         groupIdx = ate_txbf_chan_group_base_idx(pAd, channel);
+                
+         //ITxBFGetEEPROM(pAd, 0, 0, 0, &tankParams);
+         value = tankParams.TankCode[2*groupIdx];  
+         rptTank = value & 0x0F; 
+         value = tankParams.TankCode[2*groupIdx+1];
+         lcTank0 = value & 0x07; 
+         lcTank1 = (value & 0x70) >> 4; 
+
+         //write repeater tank code to rf_320[19:16]
+         mt_rf_read(pAd, 1, 0x320, &rf_val);
+         rf_val &= ~0x000F0000;
+         rf_val |= ((UINT32)rptTank)<<16 ;               
+         mt_rf_write(pAd, 1, 0x320, rf_val);
+
+         // Write LC tank code to rf(0/1) 0x2A8[D22:D20]        
+         mt_rf_read(pAd, 0, 0x2A8, &rf_val);
+         rf_val &= ~0x00700000;
+         rf_val |= ((UINT32)lcTank0)<<20 ;               
+         mt_rf_write(pAd, 0, 0x2A8, rf_val);
+
+         mt_rf_read(pAd, 1, 0x2A8, &rf_val);
+         rf_val &= ~0x00700000;
+         rf_val |= ((UINT32)lcTank1)<<20 ;               
+         mt_rf_write(pAd, 1, 0x2A8, rf_val);
+
+         DBGPRINT(RT_DEBUG_TRACE, (
+             "Load tank code from [%d],Rpt_efuse=%x,LC_efuse=%x \n"
+             "rptTank=%x, lcTank0=%x, lcTank1=%x\n",
+             groupIdx,tankParams.TankCode[2*groupIdx],tankParams.TankCode[2*groupIdx+1],rptTank,lcTank0,lcTank1));
+
+     }
+
+
+     if (CalibMode == 1) 
+     {
+         DBGPRINT(RT_DEBUG_TRACE, ("######## (2) set Low-Q mode, and manual REPA-I ########\n"));
+         set_rf_bit(pAd, "1-150-12:12-0"); //low-Q mode		
+         set_rf_bit(pAd, "1-308-29:29-1"); //manaul REPA_I 
+         set_rf_bit(pAd, "1-320-23:20-c"); //manaul REPA_I
+     
+         if (centrChanIdx >= 0) // calibration mode && group center channel  
+         {
+             // disable manual tank code
+             DBGPRINT(RT_DEBUG_TRACE, ("######## Disable manual tank code ########\n")); 
+             set_rf_bit(pAd, "1-308-28:28-0"); 
+             set_rf_bit(pAd, "1-2a8-24:24-0");
+             set_rf_bit(pAd, "0-2a8-24:24-0");
+         }  
+         else    // calibration mode, not group center channel
+         {  
+             //enable manual tank code
+             DBGPRINT(RT_DEBUG_TRACE, ("######## enable manual tank code  ########\n"));
+             set_rf_bit(pAd, "1-308-28:28-1");
+             set_rf_bit(pAd, "1-2a8-24:24-1");
+             set_rf_bit(pAd, "0-2a8-24:24-1");
+
+             groupIdx = ate_txbf_chan_group_base_idx(pAd, channel);
+                
+             value   = tankParams.TankCode[2*groupIdx];
+             rptTank = value & 0x0F; 
+             value   = tankParams.TankCode[2*groupIdx+1];
+             lcTank0 = value & 0x07; 
+             lcTank1 = (value & 0x70) >> 4; 
+
+             //write repeater tank code to rf_320[19:16]
+             mt_rf_read(pAd, 1, 0x320, &rf_val);
+             rf_val &= ~0x000F0000;
+             rf_val |= ((UINT32)rptTank)<<16 ;               
+             mt_rf_write(pAd, 1, 0x320, rf_val);
+
+             // Write LC tank code to rf(0/1) 0x2A8[D22:D20]        
+             mt_rf_read(pAd, 0, 0x2A8, &rf_val);
+             rf_val &= ~0x00700000;
+             rf_val |= ((UINT32)lcTank0)<<20 ;               
+             mt_rf_write(pAd, 0, 0x2A8, rf_val);
+
+             mt_rf_read(pAd, 1, 0x2A8, &rf_val);
+             rf_val &= ~0x00700000;
+             rf_val |= ((UINT32)lcTank1)<<20 ;               
+             mt_rf_write(pAd, 1, 0x2A8, rf_val);
+
+             DBGPRINT(RT_DEBUG_TRACE, (
+                      "Load tank code from [%d],Rpt_efuse=%x,LC_efuse=%x \n"
+                      "rptTank=%x, lcTank0=%x, lcTank1=%x\n",
+                      groupIdx,tankParams.TankCode[2*groupIdx],tankParams.TankCode[2*groupIdx+1],rptTank,lcTank0,lcTank1));
+          }   
+     }
+     
+     return TRUE;
+}
+
+/* 
+==========================================================================
+    Description:
+	If the channel is a group center channel,read tank code and save into efuse
+        	
+    Return:
+	TRUE if all parameters are OK, FALSE otherwise
+
+    Note: 
+==========================================================================
+*/
+
+BOOLEAN rtmp_ate_txbf_read_tank_code(
+     IN RTMP_ADAPTER *pAd,
+     IN UCHAR channel)
+{
+     UINT32 rf_val,regBBP;
+     INT    groupIdx;
+     UINT   rptTank,lcTank0,lcTank1;
+     ITXBF_TANK_PARAMS tankParams;
+
+     groupIdx = ate_txbf_get_chan_idx(pAd, channel, 0);
+     if (groupIdx >= 0) // group center channel 
+     {        
+         //read repeater tank code from rf_0x334[19:16], 
+         mt_rf_read(pAd, 1, 0x334, &rf_val);         
+         rptTank = (UINT)((rf_val & 0x000F0000) >> 16);
+
+         // read LC tank code from TXBE_R52(0x27d0)[6:4] WF1 , [2:0] WF0 
+         RTMP_IO_READ32(pAd, TXBE_R52, &regBBP);
+         lcTank1 = (UINT)((regBBP & 0x00000070) >> 4) ;
+         lcTank0 = (UINT)(regBBP  & 0x00000007);
+
+         /* Save new reference values in EEPROM and BBP */
+         ITxBFGetEEPROM(pAd, 0, 0, 0, &tankParams);
+
+         tankParams.TankCode[2*groupIdx] = rptTank;
+         tankParams.TankCode[2*groupIdx+1] = (lcTank0)|(lcTank1 <<4);
+         DBGPRINT(RT_DEBUG_TRACE,(
+                 "Save tank code to [%d],Rpt_efuse= %x, lc_efuse=%x\n"
+                 "rptTank=%x, lcTank0=%x, lcTank1=%x\n",
+                 groupIdx,tankParams.TankCode[2*groupIdx],tankParams.TankCode[2*groupIdx+1],rptTank,lcTank0,lcTank1));
+
+         ITxBFSetEEPROM(pAd, 0, 0, 0, &tankParams);
+
+     }
+     return TRUE;
+
+}
 
 /* 
 ==========================================================================
@@ -5007,7 +5334,7 @@ INT Set_ATE_TXBF_INIT_Proc(
 	NdisGetSystemUpTime(&stTimeChk1);
 
 	DBGPRINT(RT_DEBUG_WARN, (
-			"%s : Time consumption : %d sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+			"%s : Time consumption : %lu sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 
 	return TRUE;
 }
@@ -5026,7 +5353,7 @@ INT Set_ATE_TXBF_INIT_Proc(
 ==========================================================================
 */
 INT	Set_ATE_TXBF_DIVCAL_Proc(
-	IN	PRTMP_ADAPTER	pAd,
+	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg)
 {
 	PATE_INFO pATEInfo = &(pAd->ate);
@@ -5035,77 +5362,11 @@ INT	Set_ATE_TXBF_DIVCAL_Proc(
 	CHAR initChanArg[] = "0";
 
 	value = simple_strtol(arg, 0, 10);
-
-	if (value<0 || value>2)
+	
+	if (value<0 || value>11)
 		return FALSE;
 
-	/* G band */
-	if (value==0 || value==1)
-	{
-		pATEInfo->Channel = 1;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 14;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		/* Display delta phase information */
-		ITxBFGetEEPROM(pAd, NULL, NULL, &divParams);
-
-#ifndef MT76x2
-		DBGPRINT(RT_DEBUG_WARN, ("Divider Cal Done:\n"
-						"ch1-ch14 = [%2d, %2d] degrees\n"
-						"ant0-ant2 = [%2d, %2d] degrees\n",
-				(UCHAR)(divParams.gBeg[0]-divParams.gEnd[0])*360/256,
-				(UCHAR)(divParams.gBeg[1]-divParams.gEnd[1])*360/256,
-				(UCHAR)(divParams.gBeg[0]-divParams.gBeg[1])*360/256,
-				(UCHAR)(divParams.gEnd[0]-divParams.gEnd[1])*360/256) );
-#endif
-	}
-
-	/* A Band */
-	if (value==0 || value==2)
-	{
-		pATEInfo->Channel = 36;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 120;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-		
-#ifndef MT76x2	
-		pATEInfo->Channel = 165;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-#else
-
-		pATEInfo->Channel = 64;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 100;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 120;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 144;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 149;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-
-		pATEInfo->Channel = 173;
-		Set_ATE_INIT_CHAN_Proc(pAd, initChanArg);
-		pAd->chipOps.fITxBfDividerCalibration(pAd, 1, 0, NULL);
-#endif
-	}
+   pAd->chipOps.fITxBfDividerCalibration(pAd, value, 0, NULL);
 
 	return TRUE;
 }
@@ -5213,21 +5474,19 @@ INT	Set_ATE_TXBF_LNACAL_Proc(
 	//NdisGetSystemUpTime(&stTimeChk1);
 
 	DBGPRINT(RT_DEBUG_WARN, (
-			"%s : Time consumption : %d sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+			"%s : Time consumption : %lu sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 #endif
 
-	//if (pAd->chipCap.FlgITxBfBinWrite)
-	//{
+	if (pAd->chipCap.FlgITxBfBinWrite)
+	{
 		// Wite the calibrated phase into bit file
 		set_BinModeWriteBack_Proc(pAd, "1");
-	//}
-
+	}
+	
 	return TRUE;
 }
 
 
-
-
 /* 
 ==========================================================================
     Description:
@@ -5252,7 +5511,7 @@ INT Set_ATE_TXBF_GOLDEN_Proc(
 	USHORT eepromVal;
 	
 	ch = simple_strtol(arg, 0, 10);
-	if (rtmp_ate_txbf_cal_valid_ch(pAd, ch) == FALSE)
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;	
 
 	/* iwpriv ra0 set ATE=ATESTART */
@@ -5262,13 +5521,15 @@ INT Set_ATE_TXBF_GOLDEN_Proc(
 	Set_ATE_Proc(pAd, "APSTOP");
 #endif // CONFIG_RT2880_ATE_CMD_NEW //
 
+	/* iwpriv ra0 set ATETXBF=3 */
+	Set_ATE_TXBF_Proc(pAd, "3");
+
 	/* set the ate channel and read txpower from EEPROM and set to bbp */
 	/* iwpriv ra0 set ATECHANNEL=Channel */
 	/* iwpriv ra0 set ATETXPOWER=0 */
 	snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
 	Set_ATE_INIT_CHAN_Proc(pAd, cmdStr);
 	
-
 	/* Set self mac address as 11:11:11:11:11:11 */
 	/* iwpriv ra0 set ATESA=11:11:11:11:11:11 */
 	RTMP_IO_WRITE32(pAd, 0x1008, 0x11111111);
@@ -5279,38 +5540,31 @@ INT Set_ATE_TXBF_GOLDEN_Proc(
 	
 	/* iwpriv ra0 set ATETXBW=0 */
 	Set_ATE_TX_BW_Proc(pAd, "0");
-	
+
+    /*iwpriv rai0 set ATECHANNEL*/
+    snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
+    Set_ATE_CHANNEL_Proc(pAd, cmdStr);
+
+    /*iwpriv rai0 set ATEIPG=16*/
+	Set_ATE_IPG_Proc(pAd,"16");
+
+    /*iwpriv rai0 set ATETXMCS=4*/
+    Set_ATE_TX_MCS_Proc(pAd, "4");
+    
 	/* iwpriv ra0 set ATETXGI=0 */
 	Set_ATE_TX_GI_Proc(pAd, "0");
-	
+        
 	/* iwpriv ra0 set ATETXANT=1 */
 	Set_ATE_TX_Antenna_Proc(pAd, "1");
 	
 	/* iwpriv ra0 set ATERXANT=1 */
 	Set_ATE_RX_Antenna_Proc(pAd, "1");
 
-	/* iwpriv ra0 set ATETXFREQOFFSET=ValueOfEEPROM */
-	RT28xx_EEPROM_READ16(pAd, 0x44, eepromVal);
-	snprintf(cmdStr, sizeof(cmdStr), "%d\n", (eepromVal & 0xff));
-	Set_ATE_TX_FREQ_OFFSET_Proc(pAd, cmdStr);
-
-#ifdef RTMP_BBP
-	/* iwpriv ra0 bbp 65=29 */
-	/* iwpriv ra0 bbp 163=9d */
-	/* iwpriv ra0 bbp 173=00 */
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R65, 0x29);
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R163, 0x9d);
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R173, 0x00);
-#endif /* RTMP_BBP */
+    Set_ATE_TX_POWER0_Proc(pAd, "10");
+    Set_ATE_TX_POWER1_Proc(pAd, "10");        
 
 	/* iwpriv ra0 set ATE=RXFRAME */
 	Set_ATE_Proc(pAd, "RXFRAME");
-
-#ifdef RTMP_BBP	
-	/* reset the BBP_R173 as 0 to eliminate the compensation */
-	RTMP_BBP_IO_WRITE8_BY_REG_ID(pAd, BBP_R173, 0x00);
-#endif /* RTMP_BBP */
-
 	return TRUE;
 
 }
@@ -5319,11 +5573,16 @@ INT Set_ATE_TXBF_GOLDEN_Proc(
 ==========================================================================
     Description:
         Set to do iTxBF calibration procedures for specific channel, following show us the supported channels.
-        	1, 14, 36, 64, 128, 132, 165                in 11n
-        	1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
+								1, 14, 36, 64, 128, 132, 165                in 11n
+        							1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
 
+    Input arg:  (Could be only first one input argument)
+       chan:agc_val
+       - chan (decimal) : channel 
+       - agc_val (long hex): 0x2320[14:8] & 0x2324[14:8] agc gain setting 
+        
     Return:
-        TRUE if all parameters are OK, FALSE otherwise
+	TRUE if all parameters are OK, FALSE otherwise
 
     Note: 
    	This cmd shall only used in DUT side for calibration
@@ -5335,43 +5594,73 @@ INT Set_ATE_TXBF_Gd_Cal_Proc(
 {
 	UCHAR   ch;
 	UCHAR   cmdStr[32];
+    UINT    loopCnt = 0;
+    BOOLEAN flgIBFValid = FALSE;
 #ifdef MT76x2
-	UINT    CR_BK[35], value32;
+	UINT32  value32,agc_val;;
 #endif
+    INT     rv; 
+
+    rv = sscanf(arg, "%d:%lx", (int *)&(ch),(long unsigned int *)&(agc_val));
 	
 	/* iwpriv ra0 set ATE=ATESTART */
 	Set_ATE_Proc(pAd, "ATESTART");
-
-	ch = simple_strtol(arg, 0, 10);
-	if (rtmp_ate_txbf_cal_valid_ch(pAd, ch) == FALSE)
+	
+	//ch = simple_strtol(arg, 0, 10);
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;
 
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFCAL START, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+
 	/* iwpriv ra0 set ATECHANNEL=Channel */
 	snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
 	if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
 		return FALSE;
+
+	rtmp_ate_txbf_fix_tank_code(pAd, ch,1);  
+    
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBF INIT_CHAN, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
 	
 	/* iwpriv ra0 set ATEINITCHAN =0 */
 	if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
 		return FALSE;
+
+#ifdef MT76x2
+    /* Set RX gain after channel init */
+    if (rv == 2){
+	  RTMP_IO_READ32(pAd, AGC1_R8, &value32);
+      value32 &= (~0x00007F00);
+      value32 |= agc_val << 8;
+	  RTMP_IO_WRITE32(pAd, AGC1_R8, value32);
+
+      RTMP_IO_READ32(pAd, AGC1_R9, &value32);
+      value32 &= (~0x00007F00);
+      value32 |= agc_val << 8;
+      RTMP_IO_WRITE32(pAd, AGC1_R9, value32);
+    }
+#endif /*MT76x2*/
+
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBF INIT_CHAN_DONE, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+
+	rtmp_ate_txbf_read_tank_code(pAd,ch);
 	
 	/* iwpriv ra0 set ATETXSOUNDING=3 */
 #ifndef MT76x2	
 	if (Set_ATE_TXSOUNDING_Proc(pAd, "3") == FALSE)
 #else
 	if (Set_ATE_TXSOUNDING_Proc(pAd, "2") == FALSE)
-#endif
+#endif /* MT76x2 */
 		return FALSE;
 	
 	/* iwpriv ra0 set ETxBfNoncompress=0 */
 	if (Set_ETxBfNoncompress_Proc(pAd, "0") == FALSE)
 		return FALSE;
-	
-	/* iwpriv ra0 set ATETXMCS=0 */
-	if (Set_ATE_TX_MCS_Proc(pAd, "0") == FALSE)
+
+	/* iwpriv ra0 set ATETXMCS=8 */
+	if (Set_ATE_TX_MCS_Proc(pAd, "8") == FALSE)
 		return FALSE;
 	
-	/* iwpriv ra0 set ATETXCNT=1 */
+	/* iwpriv ra0 set ATETXCNT=2 */
 	if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
 		return FALSE;
 	
@@ -5383,47 +5672,54 @@ INT Set_ATE_TXBF_Gd_Cal_Proc(
 	if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
 		return FALSE;
 
-	RtmpOsMsDelay(300); // wait for Tag clear process being finished
+    RtmpOsMsDelay(1);
+	//RtmpOsMsDelay(300); // wait for Tag clear process being finished
 
 #ifdef MT76x2	
-	/* iwpriv ra0 set ATETXBF=1 */
+	/* iwpriv ra0 set ATETXBF=3 */
 	if (Set_ATE_TXBF_Proc(pAd, "3") == FALSE)
 		return FALSE;
 	
 	/* Disable TX Phase Compensation */
 	RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-	RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
+	RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x00000028));
 #endif	
-	/* iwpriv ra0 set ATE=TXFRAME */
-	if (Set_ATE_Proc(pAd, "TXFRAME") == FALSE)
-		return FALSE;
+
+    while ((loopCnt <5) && (flgIBFValid == FALSE))
+    {
+	    /* iwpriv ra0 set ATE=TXFRAME */
+	    if (Set_ATE_Proc(pAd, "TXFRAME") == FALSE)
+		    return FALSE;
 	
 #ifdef MT76x2
-	RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
+       RtmpOsMsDelay(20);
+       //RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
+
+	   RTMP_IO_READ32(pAd, TXBE_R8, &value32);
+	   RTMP_IO_WRITE32(pAd, TXBE_R8, value32 & (~0x080000));  //disable DPD
 #endif	
-	
-	if (pAd->chipOps.fITxBfCal(pAd, "1") == FALSE) 
-		return FALSE;
 
-	//if (pAd->chipCap.FlgITxBfBinWrite)
-	//{
-		// Wite the calibrated phase into bit file
-		set_BinModeWriteBack_Proc(pAd, "1");
-	//}
+	   flgIBFValid = pAd->chipOps.fITxBfCal(pAd, "1");
+       loopCnt++;
+       DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@ loopCnt=%d @@@@@@@@@@@@@@@\n", loopCnt));
+    }
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFCAL END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  LOOP END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
 
-	return TRUE;
+	if (pAd->chipCap.FlgITxBfBinWrite)
+	{
+        if (flgIBFValid)		
+		    set_BinModeWriteBack_Proc(pAd, "1");  // Wite the calibrated phase into bit file
+	}
 
-	
+	return TRUE;
 }
 
-
 /* 
 ==========================================================================
     Description:
 	Set to do iTxBF calibration verification procedures at sepcified channel, following show us the supported channels.
 		arg => valid values are :
-        	1, 14, 36, 64, 128, 132, 165                in 11n
-        	1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
 
     Return:
         TRUE if all parameters are OK, FALSE otherwise
@@ -5436,19 +5732,56 @@ INT Set_ATE_TXBF_Gd_Verify_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg)
 {
-	UCHAR ch;
+	UCHAR ch,i;
 	UCHAR cmdStr[32];
 	UINT32 value32;
+
+#ifdef MT76x2
+    UINT32  agc_val;;
+#endif
+    INT  rv; 
+    
+    rv = sscanf(arg, "%d:%lx", (int *)&(ch),(long unsigned int *)&(agc_val));       
 	
-	ch = simple_strtol(arg, 0, 10);
-	if (rtmp_ate_txbf_cal_valid_ch(pAd, ch) == FALSE)
+	/* iwpriv ra0 set ATE=ATESTART */
+	Set_ATE_Proc(pAd, "ATESTART");
+
+	//ch = simple_strtol(arg, 0, 10);
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;
 
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFVER START, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+
+    rtmp_ate_txbf_fix_tank_code(pAd, ch, 0); //load tank code from efuse
+
 	/* iwpriv ra0 set ATECHANNEL=Channel */
 	snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
+	
 	if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
+        DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBF INIT_CHAN, CHAN=%d @@@@@@@@@@@@@@@\n", ch));		
+
+	/* iwpriv ra0 set ATEINITCHAN =0 */
+	if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
 		return FALSE;
 
+#ifdef MT76x2
+    /* Set RX gain after channel init */
+    if (rv == 2)
+    {    
+	    RTMP_IO_READ32(pAd, AGC1_R8, &value32);
+        value32 &= (~0x00007F00);
+        value32 |= agc_val << 8;
+	    RTMP_IO_WRITE32(pAd, AGC1_R8, value32);
+
+        RTMP_IO_READ32(pAd, AGC1_R9, &value32);
+        value32 &= (~0x00007F00);
+        value32 |= agc_val << 8;
+        RTMP_IO_WRITE32(pAd, AGC1_R9, value32);
+    }
+#endif 
+
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBF INIT_CHAN_DONE, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+
 #ifndef MT76x2	
 	/* iwpriv ra0 set ATETXSOUNDING=3 */
 	if (Set_ATE_TXSOUNDING_Proc(pAd, "3") == FALSE)
@@ -5462,11 +5795,11 @@ INT Set_ATE_TXBF_Gd_Verify_Proc(
 	if (Set_ETxBfNoncompress_Proc(pAd, "0") == FALSE)
 		return FALSE;
 
-	/* iwpriv ra0 set ATETXMCS=0 */	
-	if (Set_ATE_TX_MCS_Proc(pAd, "0") == FALSE)
+	/* iwpriv ra0 set ATETXMCS=8 */	
+	if (Set_ATE_TX_MCS_Proc(pAd, "8") == FALSE)
 		return FALSE;
 
-	/* iwpriv ra0 set ATETXCNT=1 */
+	/* iwpriv ra0 set ATETXCNT=2 */
 	if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
 		return FALSE;
 		
@@ -5481,34 +5814,46 @@ INT Set_ATE_TXBF_Gd_Verify_Proc(
 	RtmpOsMsDelay(300);
 
 #ifdef MT76x2
+    /* iwpriv ra0 set ATETXBF=3 */
+    if (Set_ATE_TXBF_Proc(pAd, "3") == FALSE)
+         return FALSE;     
 	
-		/* Disable RX Phase Compensation */
-		RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-        DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32));
-		RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
-        DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32 & (~0x28))); 
-
-	//RtmpOsMsDelay(10); // waiting 10ms
+    /* Disable TX Phase Compensation */
+	RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+	RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
 
-	// LNA compensation
-        pAd->chipOps.fITxBfLNAPhaseCompensate(pAd);
+    /* Clear Tx/Rx Phase compensated values */
+    RTMP_IO_READ32(pAd, CAL_R0, &value32);
+    value32 &= ~0x60;
 
+    // Clear Tx phase
+    RTMP_IO_WRITE32(pAd, CAL_R0, value32);
+    RTMP_IO_WRITE32(pAd, TXBE_R13, 0);
+    
+    // Clear Rx phase
+    for (i=0; i<3; i++)
+    {
+        RTMP_IO_WRITE32(pAd, CAL_R0, value32 | (i << 5));
+        RTMP_IO_WRITE32(pAd, RXFE_R3,  0);
+    }       	
 
-	/* Enable TX Phase Compensation */
-	RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-	RTMP_IO_WRITE32(pAd, TXBE_R12, value32 | 0x08);
 #endif		
 	/* iwpriv ra0 set ATE=TXFRAME */
 	if (Set_ATE_Proc(pAd, "TXFRAME_IBF") == FALSE)
 		return FALSE;
 
-        RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
-	
-	
+    RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
+
 	/* iwpriv ra0 set ITxBfCal=0 */
-	return pAd->chipOps.fITxBfCal(pAd, "0");
+    pAd->chipOps.fITxBfCal(pAd, "0");
+		
+    DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFVER END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+    //DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  LOOP END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));    
+
+	return TRUE;
 }
 
+
 /* 
 ==========================================================================
     Description:
@@ -5534,7 +5879,7 @@ INT Set_ATE_TXBF_Gd_Verify_NoComp_Proc(
 	int retval;
 	
 	ch = simple_strtol(arg, 0, 10);
-	if (rtmp_ate_txbf_cal_valid_ch(pAd, ch) == FALSE)
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;
 
 	/* iwpriv ra0 set ATECHANNEL=Channel */
@@ -5554,8 +5899,8 @@ INT Set_ATE_TXBF_Gd_Verify_NoComp_Proc(
 	if (Set_ATE_TX_MCS_Proc(pAd, "0") == FALSE)
 		return FALSE;
 	
-	/* iwpriv ra0 set ATETXCNT=1 */
-	if (Set_ATE_TX_COUNT_Proc(pAd, "1") == FALSE)
+	/* iwpriv ra0 set ATETXCNT=2 */
+	if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
 		return FALSE;
 	
 	/* iwpriv ra0 set ATETXLEN=258 */
@@ -5603,10 +5948,16 @@ INT Set_ATE_TXBF_Gd_Verify_NoComp_Proc(
 ==========================================================================
     Description:
         Set to do iTxBF calibration procedures for specific channel, following show us the supported channels.
-        	1, 14, 36, 64, 128, 132, 165                in 11n
-        	1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
-
+									1, 14, 36, 64, 128, 132, 165                in 11n
+        							1, 14, 36, 64, 100, 120, 140, 149, 173		in 11ac
+        
         Combined flow of iBF phase calibration and verification
+
+    Input arg:  (Could be only first one , or first two input arguments)
+       chan:Bound:agc_val
+       - chan (decimal) : channel 
+       - Bound (hex) : Phase error verfication bound
+       - agc_val (long hex): 0x2320[14:8] & 0x2324[14:8] agc gain setting 
         
     Return:
         TRUE if all parameters are OK, FALSE otherwise
@@ -5614,127 +5965,512 @@ INT Set_ATE_TXBF_Gd_Verify_NoComp_Proc(
     Note: 
    	This cmd shall only used in DUT side for calibration
 ==========================================================================
-*/ 
+*/
 INT Set_ATE_TXBF_Gd_Phase_Cal_and_Verify_Proc(
-        IN  PRTMP_ADAPTER   pAd, 
-        IN  PSTRING         arg)
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg)
 {
-
-	UCHAR   ch;
-	UCHAR   cmdStr[32];
+	UCHAR ch;
+	UCHAR cmdStr[32];
+    UINT  i,loopCnt = 0,retryCnt,Bound;    
+    BOOLEAN flgIBFValid = FALSE;
+    BOOLEAN iBFVerifyPass = FALSE;
+    BOOLEAN flgVerifyValid;
 #ifdef MT76x2
-	UINT    CR_BK[35], value32;
+	UINT32  value32,agc_val;
 #endif
-
+    INT  rv;    
+    	
+    rv = sscanf(arg, "%d:%x:%lx", (int *)&(ch), &(Bound), (long unsigned int *)&(agc_val));
+    if (rv == 1)
+        Bound = 0x15;
+    
 	/* iwpriv ra0 set ATE=ATESTART */
 	Set_ATE_Proc(pAd, "ATESTART");
 
-	ch = simple_strtol(arg, 0, 10);
-	if (rtmp_ate_txbf_cal_valid_ch(pAd, ch) == FALSE)
-		return FALSE;
-
-	/* iwpriv ra0 set ATECHANNEL=Channel */
-	snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
-	if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
+	//ch = simple_strtol(arg, 0, 10);
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;
+    
+    retryCnt = 0;
+    while((retryCnt < 3) && (iBFVerifyPass == FALSE))
+    {
+	    /* iwpriv ra0 set ATECHANNEL=Channel */
+	    snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
+	    if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
+		    return FALSE;
 	
-	/* iwpriv ra0 set ATEINITCHAN =0 */
-	if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
-		return FALSE;
+        rtmp_ate_txbf_fix_tank_code(pAd,ch,1);	
+
+	    /* iwpriv ra0 set ATEINITCHAN =0 */
+	    if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
+		    return FALSE;
 
-	/* iwpriv ra0 set ATETXSOUNDING = 3 */
+#ifdef MT76x2
+        /* Set RX gain after channel init */
+        if (rv == 3)
+        {
+	        RTMP_IO_READ32(pAd, AGC1_R8, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+	        RTMP_IO_WRITE32(pAd, AGC1_R8, value32);
+
+            RTMP_IO_READ32(pAd, AGC1_R9, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+            RTMP_IO_WRITE32(pAd, AGC1_R9, value32);
+        }
+#endif
+
+        rtmp_ate_txbf_read_tank_code(pAd,ch);
+
+	    /* iwpriv ra0 set ATETXSOUNDING = 3 */
 #ifndef MT76x2	
-	if (Set_ATE_TXSOUNDING_Proc(pAd, "3") == FALSE)
+	    if (Set_ATE_TXSOUNDING_Proc(pAd, "3") == FALSE)
 #else
-	if (Set_ATE_TXSOUNDING_Proc(pAd, "2") == FALSE)
+	    if (Set_ATE_TXSOUNDING_Proc(pAd, "2") == FALSE)
 #endif
-		return FALSE;
-	
-	/* iwpriv ra0 set ETxBfNoncompress=0 */
-	if (Set_ETxBfNoncompress_Proc(pAd, "0") == FALSE)
-		return FALSE;
+		    return FALSE;
 	
-	/* iwpriv ra0 set ATETXMCS=0 */
-	if (Set_ATE_TX_MCS_Proc(pAd, "0") == FALSE)
-		return FALSE;
+	    /* iwpriv ra0 set ETxBfNoncompress=0 */
+	    if (Set_ETxBfNoncompress_Proc(pAd, "0") == FALSE)
+		    return FALSE;
 	
-	/* iwpriv ra0 set ATETXCNT= 2 */
-	if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
-		return FALSE;
+	    /* iwpriv ra0 set ATETXMCS=8 */
+	    if (Set_ATE_TX_MCS_Proc(pAd, "8") == FALSE)
+		    return FALSE;
 	
-	/* iwpriv ra0 set ATETXLEN=258 */
-	if (Set_ATE_TX_LENGTH_Proc(pAd, "258") == FALSE)
-		return FALSE;
+	    /* iwpriv ra0 set ATETXCNT= 2 */
+	    if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
+		    return FALSE;
 
-	/* iwpriv ra0 set InvTxBfTag=0 */
-	if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
-		return FALSE;
+	    /* iwpriv ra0 set ATETXLEN=258 */
+	    if (Set_ATE_TX_LENGTH_Proc(pAd, "258") == FALSE)
+		    return FALSE;
+
+	    /* iwpriv ra0 set InvTxBfTag=0 */
+	    if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
+		    return FALSE;
 
-	RtmpOsMsDelay(300); // wait for Tag clear process being finished
+	    RtmpOsMsDelay(1); // wait for Tag clear process being finished
 
 #ifdef MT76x2	
-	/* iwpriv ra0 set ATETXBF= 3 */
-	if (Set_ATE_TXBF_Proc(pAd, "3") == FALSE)
-		return FALSE;
-	
-	/* Disable TX Phase Compensation */
-	RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-	RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));	
+	    /* iwpriv ra0 set ATETXBF= 3 */
+	    if (Set_ATE_TXBF_Proc(pAd, "3") == FALSE)
+		    return FALSE;
+
+	    /* Disable TX Phase Compensation */
+	    RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+	    RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x00000028));	
 #endif				
+        loopCnt = 0;
+        flgIBFValid = FALSE;
+        while((loopCnt < 5) && (flgIBFValid == FALSE))
+        {
+	        /* iwpriv ra0 set ATE=TXFRAME */
+	        if (Set_ATE_Proc(pAd, "TXFRAME") == FALSE)
+		        return FALSE;
+#ifdef MT76x2
+	        RtmpOsMsDelay(20); // waiting 100ms for making sure TxBf profiles being calculated
+   
+	        RTMP_IO_READ32(pAd, TXBE_R8, &value32);
+	        RTMP_IO_WRITE32(pAd, TXBE_R8, value32 & (~0x080000));  //disable DPD
+#endif	
 
-	/* iwpriv ra0 set ATE=TXFRAME */
-	if (Set_ATE_Proc(pAd, "TXFRAME") == FALSE)
-		return FALSE;
-	
+	        flgIBFValid = pAd->chipOps.fITxBfCal(pAd, "1");
+            loopCnt++;
+            //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ loopCnt=%d @@@@@@@@@@@@@@@\n", loopCnt));
+        }     
+        
+        DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFCAL END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+        DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  LOOP END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+    
+        if (pAd->chipCap.FlgITxBfBinWrite)
+        {
+            if (flgIBFValid)		
+		        set_BinModeWriteBack_Proc(pAd, "1");  // Wite the calibrated phase into bit file
+        }
+
+        //================== Verify ==================    
+        /* iwpriv ra0 set InvTxBfTag=0 */
+        if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
+            return FALSE;
+    
+        RtmpOsMsDelay(1);  // wait for Tag clear process being finished
+    
 #ifdef MT76x2
-	RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
+        /* Disable RX Phase Compensation */
+        //RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+        //DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32));
+        //RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
+        //DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32 & (~0x28))); 
+    
+        //RtmpOsMsDelay(10); // waiting 10ms
+
+        /* Disable TX Phase Compensation */
+        RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+        RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
+    
+        /* Clear Tx/Rx Phase compensated values */
+        RTMP_IO_READ32(pAd, CAL_R0, &value32);
+        value32 &= ~0x60;
+    
+        // Clear Tx phase
+        RTMP_IO_WRITE32(pAd, CAL_R0, value32);
+        RTMP_IO_WRITE32(pAd, TXBE_R13, 0);
+    
+        // Clear Rx phase
+        for (i=0; i<3; i++)
+        {
+            RTMP_IO_WRITE32(pAd, CAL_R0, value32 | (i << 5));
+            RTMP_IO_WRITE32(pAd, RXFE_R3,  0);
+        }       	
+
 #endif	
+        
+        /* iwpriv ra0 set ATE=TXFRAME_IBF */
+        if (Set_ATE_Proc(pAd, "TXFRAME_IBF") == FALSE)
+            return FALSE;
+        
+        RtmpOsMsDelay(20); // waiting 100ms for making sure TxBf profiles being calculated
+                   
+        flgVerifyValid = pAd->chipOps.fITxBfCal(pAd, "0");
+        
+        iBFVerifyPass = TRUE;
+        if(((pAd->iBFPhaseErrorBackup> Bound) && (pAd->iBFPhaseErrorBackup < (0xFF-Bound)))||
+            (flgVerifyValid != TRUE))
+            iBFVerifyPass = FALSE;
+ 
+        retryCnt++;
+        //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ Error=%x @@@@@@@@@@@@@@@\n", pAd->iBFPhaseErrorBackup));
+        //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ retryCnt=%d @@@@@@@@@@@@@@@\n", retryCnt));
+    }    
+    return TRUE;
+        
+}
 
-	if (pAd->chipOps.fITxBfCal(pAd, "1") == FALSE) 
+/* 
+==========================================================================
+    Description:
+        Set to do iTxBF calibration procedures for specific channel, following show us the supported channels.
+									1, 14, 36, 64, 128, 132, 165                in 11n
+        							1, 14, 36, 64, 100, 120, 140, 149, 173		in 11ac
+        
+        Combined flow of iBF phase calibration and verification
+
+     Input arg: (Could be only first one , or first two input arguments)
+        chan:Bound:agc_val
+        - chan (decimal) : channel 
+        - Bound (hex) : Phase error verfication bound
+        - agc_val (long hex): 0x2320 & 0x2324 agc gain setting 
+        
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+
+    Note: 
+   	This cmd shall only used in DUT side for calibration
+==========================================================================
+*/
+INT Set_ATE_TXBF_Gd_Phase_Cal_Init_Verify_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg)
+{
+
+	UCHAR ch;
+	UCHAR cmdStr[32];
+    UINT  i,loopCnt,retryCnt,Bound;    
+    BOOLEAN flgIBFValid;
+    BOOLEAN iBFVerifyPass = FALSE;
+    BOOLEAN flgVerifyValid;
+#ifdef MT76x2
+	UINT32  value32,agc_val;
+#endif /*MT76x2*/
+	
+    INT  rv; 
+    	
+    rv = sscanf(arg, "%d:%x:%lx", (int *)&(ch), &(Bound), (long unsigned int *)&(agc_val));
+    if (rv == 1)
+        Bound = 0x15;    // default value for error Bound 
+
+	/* iwpriv ra0 set ATE=ATESTART */
+	Set_ATE_Proc(pAd, "ATESTART");
+
+	//ch = simple_strtol(arg, 0, 10);
+	if (rtmp_ate_txbf_cal_valid_ch_new(pAd, ch) == FALSE)
 		return FALSE;
     
-	//if (pAd->chipCap.FlgITxBfBinWrite)
-	//{
-		// Wite the calibrated phase into bit file
-		set_BinModeWriteBack_Proc(pAd, "1");
-	//}
+    retryCnt = 0;
+    while((retryCnt < 3) && (iBFVerifyPass == FALSE))
+    {
+	    /* iwpriv ra0 set ATECHANNEL=Channel */
+	    snprintf(cmdStr, sizeof(cmdStr), "%d\n", ch);
+	    if (Set_ATE_CHANNEL_Proc(pAd, cmdStr) == FALSE)
+		    return FALSE;
+	
+        rtmp_ate_txbf_fix_tank_code(pAd,ch,1);	
+
+	    /* iwpriv ra0 set ATEINITCHAN =0 */
+	    if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
+		    return FALSE;
+
+#ifdef MT76x2    
+	    /* Set RX gain after channel init */
+        if (rv == 3)
+        {
+            RTMP_IO_READ32(pAd, AGC1_R8, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+            RTMP_IO_WRITE32(pAd, AGC1_R8, value32);
+    
+            RTMP_IO_READ32(pAd, AGC1_R9, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+            RTMP_IO_WRITE32(pAd, AGC1_R9, value32);
+        }
+#endif /*MT76x2*/
+    
+        rtmp_ate_txbf_read_tank_code(pAd,ch);
+
+	    /* iwpriv ra0 set ATETXSOUNDING = 3 */
+#ifndef MT76x2	
+	    if (Set_ATE_TXSOUNDING_Proc(pAd, "3") == FALSE)
+#else
+	    if (Set_ATE_TXSOUNDING_Proc(pAd, "2") == FALSE)
+#endif /*MT76x2*/
+		    return FALSE;
+	
+	    /* iwpriv ra0 set ETxBfNoncompress=0 */
+	    if (Set_ETxBfNoncompress_Proc(pAd, "0") == FALSE)
+		    return FALSE;
+	
+	    /* iwpriv ra0 set ATETXMCS=8 */
+	    if (Set_ATE_TX_MCS_Proc(pAd, "8") == FALSE)
+		    return FALSE;
+	
+	    /* iwpriv ra0 set ATETXCNT= 2 */
+	    if (Set_ATE_TX_COUNT_Proc(pAd, "2") == FALSE)
+		    return FALSE;
+
+	    /* iwpriv ra0 set ATETXLEN=258 */
+	    if (Set_ATE_TX_LENGTH_Proc(pAd, "258") == FALSE)
+		    return FALSE;
 
-//===============================================Verify    
+	    /* iwpriv ra0 set InvTxBfTag=0 */
+	    if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
+		    return FALSE;
+
+	    RtmpOsMsDelay(1); // wait for Tag clear process being finished
+
+#ifdef MT76x2	
+	    /* iwpriv ra0 set ATETXBF= 3 */
+	    if (Set_ATE_TXBF_Proc(pAd, "3") == FALSE)
+		    return FALSE;
+
+	    /* Disable TX Phase Compensation */
+	    RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+	    RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x00000028));	
+#endif /*MT76x2*/				
+        loopCnt = 0;
+        flgIBFValid = FALSE;
+        while((loopCnt < 5) && (flgIBFValid == FALSE))
+        {
+	        /* iwpriv ra0 set ATE=TXFRAME */
+	        if (Set_ATE_Proc(pAd, "TXFRAME") == FALSE)
+		       return FALSE;
+#ifdef MT76x2
+	        RtmpOsMsDelay(20); // waiting 100ms for making sure TxBf profiles being calculated
+   
+	        RTMP_IO_READ32(pAd, TXBE_R8, &value32);
+	        RTMP_IO_WRITE32(pAd, TXBE_R8, value32 & (~0x080000));  //disable DPD
+#endif /*MT76x2*/	
+	        flgIBFValid = pAd->chipOps.fITxBfCal(pAd, "1");
+            loopCnt++;
+            //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ loopCnt=%d @@@@@@@@@@@@@@@\n", loopCnt));
+        }        
+        DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  TXBFCAL END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+        DBGPRINT(RT_DEBUG_TRACE, ("@@@@@@@@@@@@@@@  LOOP END, CHAN=%d @@@@@@@@@@@@@@@\n", ch));
+    
+	    if (pAd->chipCap.FlgITxBfBinWrite)
+	    {
+            if (flgIBFValid)		
+		        set_BinModeWriteBack_Proc(pAd, "1");  // Wite the calibrated phase into bit file
+	    }
+
+        //===================== Verify =====================
+        rtmp_ate_txbf_fix_tank_code(pAd, ch, 0); //load tank code from efuse
+               
+        /* iwpriv ra0 set ATEINITCHAN =0 */
+        if (Set_ATE_INIT_CHAN_Proc(pAd, "0") == FALSE)
+            return FALSE;
+
+#ifdef MT76x2 
+        /* Set RX gain after channel init */
+        if(rv ==3){        
+            RTMP_IO_READ32(pAd, AGC1_R8, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+            RTMP_IO_WRITE32(pAd, AGC1_R8, value32);
+        
+            RTMP_IO_READ32(pAd, AGC1_R9, &value32);
+            value32 &= (~0x00007F00);
+            value32 |= agc_val << 8;
+            RTMP_IO_WRITE32(pAd, AGC1_R9, value32);
+        }
+#endif  /*MT76x2*/	
 
         /* iwpriv ra0 set InvTxBfTag=0 */
         if (Set_InvTxBfTag_Proc(pAd, "0") == FALSE)
             return FALSE;
     
-        RtmpOsMsDelay(300);  // wait for Tag clear process being finished
+        RtmpOsMsDelay(1);  // wait for Tag clear process being finished
     
 #ifdef MT76x2
         
         /* Disable RX Phase Compensation */
+        //RTMP_IO_READ32(pAd, TXBE_R12, &value32);
+        //DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32));
+        //RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
+        //DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32 & (~0x28))); 
+    
+        //RtmpOsMsDelay(10); // waiting 10ms
+
+        /* Disable TX Phase Compensation */
         RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-        DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32));
         RTMP_IO_WRITE32(pAd, TXBE_R12, value32 & (~0x28));
-        DBGPRINT(RT_DEBUG_OFF, ("TXBE_R12 = 0x%08x\n", value32 & (~0x28))); 
     
-        //RtmpOsMsDelay(10); // waiting 10ms
+        /* Clear Tx/Rx Phase compensated values */
+        RTMP_IO_READ32(pAd, CAL_R0, &value32);
+        value32 &= ~0x60;
     
-        // LNA compensation
-        pAd->chipOps.fITxBfLNAPhaseCompensate(pAd);
-        
-        /* Enable TX Phase Compensation */
-        RTMP_IO_READ32(pAd, TXBE_R12, &value32);
-        RTMP_IO_WRITE32(pAd, TXBE_R12, value32 | 0x08);
-#endif		
+        // Clear Tx phase
+        RTMP_IO_WRITE32(pAd, CAL_R0, value32);
+        RTMP_IO_WRITE32(pAd, TXBE_R13, 0);
+    
+        // Clear Rx phase
+        for (i=0; i<3; i++)
+        {
+            RTMP_IO_WRITE32(pAd, CAL_R0, value32 | (i << 5));
+            RTMP_IO_WRITE32(pAd, RXFE_R3,  0);
+        }       	
+
+#endif /*MT76x2*/			
         /* iwpriv ra0 set ATE=TXFRAME_IBF */
         if (Set_ATE_Proc(pAd, "TXFRAME_IBF") == FALSE)
             return FALSE;
         
-        RtmpOsMsDelay(100); // waiting 100ms for making sure TxBf profiles being calculated
+        RtmpOsMsDelay(20); // waiting 100ms for making sure TxBf profiles being calculated
         
         /* iwpriv ra0 set ITxBfCal=0 */
-        return pAd->chipOps.fITxBfCal(pAd, "0");
+        flgVerifyValid = pAd->chipOps.fITxBfCal(pAd, "0");
+
+        iBFVerifyPass = TRUE;
+        if(((pAd->iBFPhaseErrorBackup> Bound) && (pAd->iBFPhaseErrorBackup < (0xFF-Bound)))||
+           (flgVerifyValid != TRUE))  
+           iBFVerifyPass = FALSE;
+        
+        retryCnt++;
+        //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ Error=%x @@@@@@@@@@@@@@@\n", pAd->iBFPhaseErrorBackup));      
+        //DBGPRINT(RT_DEBUG_OFF, ("@@@@@@@@@@@@@@@ retryCnt=%d @@@@@@@@@@@@@@@\n", retryCnt));
+    }    
+    return TRUE;
         
 }
 
+/* 
+==========================================================================
+    Description:
+        Check efuse to check iBF calibration 
+         - Check if there is any channel whose iBF is not calibrated
+         - Check if there is any channel whose calibration error is too big
+         
+     Input arg:
+        - Bound (hex) : Phase error verfication bound
+        
+    Return:
+        TRUE if all parameters are OK, FALSE otherwise
+
+    Note: 
+   	This cmd shall only used in DUT side for calibration
+==========================================================================
+*/
+UINT iBFCenterChIdx[5]={1, 3, 5, 8, 11};
+
+INT Set_ATE_TXBF_Gd_Check_Error_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg)
+{
+    UINT    i,idx, Bound,iBFCalibmode;
+    INT     rv;
+    BOOLEAN flgPass;
+
+    rv = sscanf(arg, "%x:%d", &(Bound),&(iBFCalibmode));
+
+    if(rv !=2)
+    {
+      iBFCalibmode = 2;
+    }
+    
+    ITXBF_PHASE_PARAMS phaseParams;
+    ITxBFGetEEPROM(pAd, &phaseParams, 0, 0, 0);
+
+    flgPass = TRUE;
+    if (iBFCalibmode==2)  // 13 channel calibration mode
+    { 
+        for(idx=0; idx<13 ; idx++)            
+        {
+            DBGPRINT(RT_DEBUG_TRACE, ("#### EFUSE Phase[%d]=%x\n",idx,phaseParams.E1aPhase[idx] ));
+            if(phaseParams.E1aPhase[idx] == 0xFF)
+            {
+                DBGPRINT(RT_DEBUG_OFF, ("#### ERROR: Not Calibrated : Channel %d\n",iBFCHTbl_new[idx]));         
+                flgPass = FALSE;
+            }
+        }
+
+        for(idx=0; idx<13 ; idx++)            
+        {         
+            DBGPRINT(RT_DEBUG_TRACE, ("#### EFUSE Error[%d]=%x\n",idx,phaseParams.E1aPhaseErr[idx] ));
+            if((phaseParams.E1aPhaseErr[idx] > Bound) && (phaseParams.E1aPhaseErr[idx] < (0xFF-Bound)))
+            {
+                DBGPRINT(RT_DEBUG_OFF, ("#### ERROR: Calibration Error too Big : Channel %d,Error=0x%x\n",iBFCHTbl_new[idx],phaseParams.E1aPhaseErr[idx]));
+                flgPass = FALSE;
+            }   
+        }
+    }
+    else // 5 channel calibration mode
+    { 
+        
+       for(i=0; i<5 ; i++)            
+       {              
+           idx = iBFCenterChIdx[i];
+           DBGPRINT(RT_DEBUG_TRACE, ("#### EFUSE Phase[%d]=%x\n",idx,phaseParams.E1aPhase[idx]));
+           if(phaseParams.E1aPhase[idx] == 0xFF)         
+           {
+               DBGPRINT(RT_DEBUG_OFF, ("#### ERROR: Not Calibrated : Channel %d\n",iBFCHTbl_new[idx]));         
+               flgPass = FALSE;
+           }
+       }
+
+       for(i=0; i<5 ; i++)            
+       {
+           idx = iBFCenterChIdx[i];
+           DBGPRINT(RT_DEBUG_TRACE, ("#### EFUSE Error[%d]=%x\n",idx,phaseParams.E1aPhaseErr[idx] ));
+           if((phaseParams.E1aPhaseErr[idx] > Bound) && (phaseParams.E1aPhaseErr[idx] < (0xFF-Bound)))
+           {
+               DBGPRINT(RT_DEBUG_OFF, ("#### ERROR: Calibration Error too Big : Channel %d,Error=0x%x\n",iBFCHTbl_new[idx],phaseParams.E1aPhaseErr[idx]));
+               flgPass = FALSE;
+           }
+       }
+
+    }
+    if(flgPass)
+        DBGPRINT(RT_DEBUG_OFF, ("#### ITxBf Calibration PASS ####\n"));   
+    else
+        DBGPRINT(RT_DEBUG_OFF, ("#### ITxBf Calibration FAIL ####\n"));       
+
+    return TRUE;
+}
+
+
 #ifdef MT76x2
 /* 
 ==========================================================================
@@ -5804,7 +6540,7 @@ INT Set_ATE_TXBF_Intloop_Cal_Proc(
 	NdisGetSystemUpTime(&stTimeChk1);
 
 	DBGPRINT(RT_DEBUG_WARN, (
-			"%s : Time consumption : %d sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+			"%s : Time consumption : %lu sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 
 	if (pAd->chipCap.FlgITxBfBinWrite)
 	{
@@ -5813,18 +6549,16 @@ INT Set_ATE_TXBF_Intloop_Cal_Proc(
 	}
 	
 	return TRUE;
-	
 }
 
 
-
 /* 
 ==========================================================================
     Description:
 	Set to do iTxBF calibration verification procedures at sepcified channel, following show us the supported channels.
 		arg => valid values are :
 								1, 14, 36, 64, 128, 132, 165                in 11n
-        							1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
+        						1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
 
     Return:
 	TRUE if all parameters are OK, FALSE otherwise
@@ -5895,7 +6629,7 @@ INT Set_ATE_TXBF_Intloop_Phase_Verify_Proc(
 	NdisGetSystemUpTime(&stTimeChk1);
 
 	DBGPRINT(RT_DEBUG_WARN, (
-			"%s : Time consumption : %d sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+			"%s : Time consumption : %lu sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 	
 	return TRUE;
 }
@@ -5907,7 +6641,7 @@ INT Set_ATE_TXBF_Intloop_Phase_Verify_Proc(
 	Set to do iTxBF calibration verification procedures at sepcified channel, following show us the supported channels.
 		arg => valid values are :
 								1, 14, 36, 64, 128, 132, 165                in 11n
-        							1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
+        						1, 14, 36, 64, 100, 120, 140, 149, 173  in 11ac
 
     Return:
 	TRUE if all parameters are OK, FALSE otherwise
@@ -5991,7 +6725,7 @@ INT Set_ATE_TXBF_Intloop_Phase_Cal_and_Verify_Proc(
 	NdisGetSystemUpTime(&stTimeChk1);
 
 	DBGPRINT(RT_DEBUG_WARN, (
-			"%s : Time consumption : %d sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+			"%s : Time consumption : %lu sec\n",__FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 	
 	if (pAd->chipCap.FlgITxBfBinWrite)
 	{
@@ -6002,8 +6736,9 @@ INT Set_ATE_TXBF_Intloop_Phase_Cal_and_Verify_Proc(
 	return TRUE;
 }
 
-#endif /* MT76x2 */
 
+#endif /* MT76x2 */
+#endif /*TXBF_SUPPORT*/
 INT Set_ATE_ForceBBP_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg)
@@ -6025,9 +6760,7 @@ INT Set_ATE_ForceBBP_Proc(
 
 	return TRUE;
 }
-
-
-#endif /* TXBF_SUPPORT */
+//#endif /* TXBF_SUPPORT */
 
 
 /* 
@@ -6188,6 +6921,37 @@ INT	Set_ATE_Fixed_Payload_Proc(
 
 
 
+/* 
+==========================================================================
+    Description:
+        Enable ATE test time reduction.
+        
+        0: disable
+        1: enable
+        
+        Return:
+        	TRUE if all parameters are OK, FALSE otherwise
+==========================================================================
+*/
+INT	Set_ATE_TTR_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg)
+{
+	UINT32 value = simple_strtol(arg, 0, 10);
+
+	if (value > 0)
+	{
+		pAd->ate.bTestTimeReduction = TRUE;
+		DBGPRINT(RT_DEBUG_TRACE, ("ATETTR = TRUE , test time reduction enabled!\n"));
+	}
+	else
+	{
+		pAd->ate.bTestTimeReduction = FALSE;
+		DBGPRINT(RT_DEBUG_TRACE, ("ATETTR = FALSE , test time reduction disabled!\n"));
+	}	
+
+	return TRUE;
+}
 
 INT	Set_ATE_Show_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
@@ -6430,22 +7194,63 @@ INT RT6352_ATETempCalibration(
 #endif /* RT6352 */	
 
 
-#ifdef RTMP_TEMPERATURE_CALIBRATION
+
+
+#if defined(RTMP_INTERNAL_TX_ALC) || defined(RTMP_TEMPERATURE_COMPENSATION)
+INT Set_ATE_TSSI_CALIBRATION_EX_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PSTRING			arg)
+{    
+	PATE_INFO pATEInfo = &(pAd->ate);
+
+	if (pATEInfo->pChipStruct->ExtendedTssiCalibration != NULL)
+	{
+		pATEInfo->pChipStruct->ExtendedTssiCalibration(pAd, arg);
+	}
+	else
+	{
+		RTMP_CHIP_ATE_TSSI_CALIBRATION_EXTEND(pAd, arg);
+	}
+	
+	return TRUE;
+}
+#endif /* defined(RTMP_INTERNAL_TX_ALC) || defined(RTMP_TEMPERATURE_COMPENSATION) */
+
+#ifdef RTMP_TEMPERATURE_COMPENSATION
+
+
+
+INT Set_ATE_READ_EXTERNAL_TSSI_Proc(
+	IN	PRTMP_ADAPTER	pAd,
+	IN	PSTRING			arg)
+{
+
+	RTMP_CHIP_ATE_READ_EXTERNAL_TSSI(pAd, arg);
+
+	return TRUE;
+}
+#endif /* RTMP_TEMPERATURE_COMPENSATION */
+
+#if defined(RTMP_TEMPERATURE_CALIBRATION) || defined(RTMP_TEMPERATURE_COMPENSATION)
 INT Set_ATE_TEMP_CAL_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg)
 {
 	INT ret = TRUE;
 
+#ifdef RTMP_TEMPERATURE_CALIBRATION
 #ifdef RT6352
 	if (IS_RT6352(pAd))
 		ret = RT6352_ATETempCalibration(pAd, arg);		
 #endif /* RT6352 */	
+#endif /* RTMP_TEMPERATURE_CALIBRATION */
+
+#ifdef RTMP_TEMPERATURE_COMPENSATION
+#endif /* RTMP_TEMPERATURE_COMPENSATION */
 
 	return ret;
 }
 
-
 INT Set_ATE_SHOW_TSSI_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg)
@@ -6456,6 +7261,10 @@ INT Set_ATE_SHOW_TSSI_Proc(
 	CHAR BbpR49 = 0;
 #endif /* RT6352 */
 
+#ifdef RTMP_TEMPERATURE_COMPENSATION
+#endif /* RTMP_TEMPERATURE_COMPENSATION */
+
+#ifdef RTMP_TEMPERATURE_CALIBRATION
 #ifdef RT6352
 	if (IS_RT6352(pAd))
 	{
@@ -6508,32 +7317,11 @@ INT Set_ATE_SHOW_TSSI_Proc(
 		printk("BBP R49: 0x%02X\n", BbpR49);
 	}
 #endif /* RT6352 */	
-
-	return ret;
-}
 #endif /* RTMP_TEMPERATURE_CALIBRATION */
 
-
-#if defined(RTMP_INTERNAL_TX_ALC) || defined(RTMP_TEMPERATURE_COMPENSATION)
-INT Set_ATE_TSSI_CALIBRATION_EX_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
-{    
-	PATE_INFO pATEInfo = &(pAd->ate);
-
-	if (pATEInfo->pChipStruct->ExtendedTssiCalibration != NULL)
-	{
-		pATEInfo->pChipStruct->ExtendedTssiCalibration(pAd, arg);
-	}
-	else
-	{
-		RTMP_CHIP_ATE_TSSI_CALIBRATION_EXTEND(pAd, arg);
-	}
-	
-	return TRUE;
+	return ret;
 }
-#endif /* defined(RTMP_INTERNAL_TX_ALC) || defined(RTMP_TEMPERATURE_COMPENSATION) */
-
+#endif /* defined(RTMP_TEMPERATURE_CALIBRATION) || defined(RTMP_TEMPERATURE_COMPENSATION) */
 
 #ifdef RTMP_INTERNAL_TX_ALC
 
@@ -6720,19 +7508,6 @@ INT RT335xATETssiCalibrationExtend(
 #endif /* RTMP_INTERNAL_TX_ALC */
 
 
-#ifdef RTMP_TEMPERATURE_COMPENSATION
-
-
-INT Set_ATE_READ_EXTERNAL_TSSI_Proc(
-	IN	PRTMP_ADAPTER	pAd,
-	IN	PSTRING			arg)
-{
-	RTMP_CHIP_ATE_READ_EXTERNAL_TSSI(pAd, arg);
-	return TRUE;
-}
-#endif /* RTMP_TEMPERATURE_COMPENSATION */
-
-
 
 
 
@@ -6768,7 +7543,7 @@ INT Set_ATE_Load_CR_Proc(
 
 	if (arg)
 	{
-		rv = sscanf(arg, "%u-%u-%u", &(mode), (UINT32 *)&(temp_level), (UINT32 *)&(channel));
+		rv = sscanf(arg, "%u-%u-%u", &(mode), (unsigned int *)&(temp_level), (unsigned int *)&(channel));
 		DBGPRINT(RT_DEBUG_TRACE, ("%s():mode = %d, temp_level = %d, channel = %d\n", __FUNCTION__, mode, temp_level, channel));
 		if (rv == 3)
 		{
@@ -7114,7 +7889,7 @@ NDIS_STATUS ATEInit(
 	}
 
 #ifdef TXBF_SUPPORT
-	pATEInfo->bTxBF = FALSE;	
+	pATEInfo->bTxBF      = FALSE;	
 	pATEInfo->bITxBf_Cal = FALSE;
 #endif /* TXBF_SUPPORT */
 #ifdef RTMP_MAC_PCI
@@ -7615,7 +8390,7 @@ VOID ATEPeriodicExec(
 #ifdef MT76x2
 		if ( IS_MT76x2(pAd) )
 		{
-			if ( (pATEInfo->Mode == ATE_TXFRAME) && (pATEInfo->bAutoTxAlc == TRUE) )			{
+			if ( (pATEInfo->Mode == ATE_TXFRAME) && (pATEInfo->bAutoTxAlc == TRUE) ){
 				UCHAR i=0;
 				
 				pAd->ate.bSendTSSICmdOnly = TRUE;
diff --git a/mt76x2/ate/common/rt_qa.c b/mt76x2/ate/common/rt_qa.c
old mode 100644
new mode 100755
index e3548c1..b367034
--- a/mt76x2/ate/common/rt_qa.c
+++ b/mt76x2/ate/common/rt_qa.c
@@ -1067,7 +1067,6 @@ INT DO_RACFG_CMD_ATE_MT76x2_Calibration(
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
 	IN  struct ate_racfghdr *pRaCfg)
 {
-	PATE_INFO pATEInfo = &(pAd->ate);
 	USHORT length;
 	UINT32 size, cal_id, param0;
 
@@ -1370,7 +1369,7 @@ static  INT DO_RACFG_CMD_ATE_START_TX_FRAME(
 	return NDIS_STATUS_SUCCESS;
 }	
 
-
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_START_TX_FRAME_V2(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
@@ -1455,13 +1454,14 @@ static	INT DO_RACFG_CMD_ATE_SET_IPG(
 	value = OS_NTOHS(value);
 	pATEInfo->IPG = value;
 	DBGPRINT(RT_DEBUG_TRACE,("set pATEInfo->IPG : (%d)\n",pATEInfo->IPG));
-	snprintf((char *)str, sizeof(str), "%ld", value);
+	snprintf((char *)str, sizeof(str), "%lu", value);
 	Set_ATE_IPG_Proc(pAd, str);
 	
 	ResponseToGUI(pRaCfg, wrq, sizeof(pRaCfg->status), NDIS_STATUS_SUCCESS);
 
 	return NDIS_STATUS_SUCCESS;
 }
+#endif /* MT76x2 */
 
 
 static  INT DO_RACFG_CMD_ATE_SET_BW(
@@ -1558,14 +1558,12 @@ static  INT DO_RACFG_CMD_ATE_SET_TX_POWER2(
 }
 #endif /* DOT11N_SS3_SUPPORT */
 
-
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_TX_POWER_EVAL(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
 	IN  struct ate_racfghdr *pRaCfg)
 {
-	PATE_INFO pATEInfo = &(pAd->ate);
-
 	DBGPRINT(RT_DEBUG_TRACE,("DO_RACFG_CMD_ATE_TX_POWER_EVAL\n"));
 	
 	Set_ATE_TX_POWER_EVALUATION_Proc(pAd, "1");
@@ -1574,7 +1572,7 @@ static  INT DO_RACFG_CMD_ATE_TX_POWER_EVAL(
 
 	return NDIS_STATUS_SUCCESS;
 }
-
+#endif
 
 static  INT DO_RACFG_CMD_ATE_SET_FREQ_OFFSET(
 	IN	PRTMP_ADAPTER	pAd,
@@ -1597,6 +1595,8 @@ static  INT DO_RACFG_CMD_ATE_SET_FREQ_OFFSET(
 
 	return NDIS_STATUS_SUCCESS;
 }
+
+#ifdef MT76x2
 static INT DO_RACFG_CMD_ATE_SET_AUTO_RESPONDER(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
@@ -1618,6 +1618,7 @@ static INT DO_RACFG_CMD_ATE_SET_AUTO_RESPONDER(
 
 	return NDIS_STATUS_SUCCESS;
 }
+
 static  INT DO_RACFG_CMD_ATE_SET_TSSI_ON_OFF(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
@@ -1625,7 +1626,6 @@ static  INT DO_RACFG_CMD_ATE_SET_TSSI_ON_OFF(
 {
 	PATE_INFO pATEInfo = &(pAd->ate);
 	SHORT    value = 0;
-	UINT32 ret;
 
 	DBGPRINT(RT_DEBUG_TRACE,("DO_RACFG_CMD_ATE_SET_TSSI_ON_OFF\n"));				
 
@@ -1669,6 +1669,7 @@ static  INT DO_RACFG_CMD_ATE_SET_TSSI_ON_OFF(
 
 	return NDIS_STATUS_SUCCESS;
 }
+#endif 
 
 static  INT DO_RACFG_CMD_ATE_GET_STATISTICS(
 	IN	PRTMP_ADAPTER	pAd,
@@ -1882,14 +1883,13 @@ static  INT DO_RACFG_CMD_ATE_SET_ADDR3(
 	return NDIS_STATUS_SUCCESS;
 }
 
-
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_SET_FIXED_PAYLOAD(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
 	IN  struct ate_racfghdr *pRaCfg)
 {
 	SHORT    value = 0;
-	PATE_INFO pATEInfo = &(pAd->ate);
 
 	memcpy((PUCHAR)&value, (PUCHAR)&(pRaCfg->status), 2);
 	value = OS_NTOHS(value);
@@ -1904,7 +1904,7 @@ static  INT DO_RACFG_CMD_ATE_SET_FIXED_PAYLOAD(
 
 	return NDIS_STATUS_SUCCESS;
 }
-
+#endif
 
 static  INT DO_RACFG_CMD_ATE_SET_RATE(
 	IN	PRTMP_ADAPTER	pAd,
@@ -1936,6 +1936,7 @@ static  INT DO_RACFG_CMD_ATE_SET_RATE(
 
 
 #ifdef DOT11_VHT_AC
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_SET_VHT_NSS(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
@@ -1964,6 +1965,7 @@ static  INT DO_RACFG_CMD_ATE_SET_VHT_NSS(
 
 	return NDIS_STATUS_SUCCESS;
 }
+#endif /* MT76x2 */
 #endif /* VHT_SUPPORT */
 
 static  INT DO_RACFG_CMD_ATE_SET_TX_FRAME_LEN(
@@ -2213,13 +2215,13 @@ static  INT DO_RACFG_CMD_ATE_BBP_WRITE_BULK(
 	return NDIS_STATUS_SUCCESS;
 }
 
-
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_MPS_SetSeqData(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
 	IN  struct ate_racfghdr *pRaCfg)
 {
-	UINT iCount,length=0,seqdata_test=0,i=0,Value=0;
+	UINT iCount,length=0;
 
 	PATE_INFO pATEInfo = &(pAd->ate);
 	
@@ -2310,7 +2312,7 @@ static  INT DO_RACFG_CMD_ATE_MPS_SetPowerGain(
 
 	return NDIS_STATUS_SUCCESS;
 }
-
+#endif /* MT76x2 */
 
 static INT MPSThread(IN ULONG Context)
 {
@@ -2318,9 +2320,7 @@ static INT MPSThread(IN ULONG Context)
 	PRTMP_ADAPTER	pAd = NULL;
 	PATE_INFO 		pATEInfo = NULL;
 	USHORT i;
-	NDIS_STATUS		ret;
 	UINT32 MTxCycle, MacReg = 0;
-	int 	Status = 0;
 
 	pTask = (RTMP_OS_TASK *)Context;
 	pAd = (PRTMP_ADAPTER)RTMP_OS_TASK_DATA_GET(pTask);
@@ -2918,8 +2918,8 @@ static  INT DO_RACFG_CMD_ATE_MT_RF_READ_BULK_BANK(
 //	DBGPRINT(RT_DEBUG_WARN,("\n\n"));
 	for (pos = offset; pos < (offset+len); pos += 4)
 	{
-		*(UINT32 *)(&pRaCfg->data[pos - offset]) = 0;
-		mt_rf_read(pAd, bank, pos, (UINT32 *)&pRaCfg->data[pos - offset]);
+		*(UINT32 *)(&pRaCfg->data[pos - offset])= 0;
+		mt_rf_read(pAd, bank, pos, (u32 *)&pRaCfg->data[pos - offset]);
 //		DBGPRINT(RT_DEBUG_WARN,("rf bank%u r R%u=0x%02X\n"
 //			, bank, pos, pRaCfg->data[pos - offset]));
 		DBGPRINT(RT_DEBUG_TRACE,("rf bank%u r 0x%04X=0x%04X\n"
@@ -2974,7 +2974,7 @@ static  INT DO_RACFG_CMD_ATE_MT_RF_WRITE_BULK_BANK(
 //	DBGPRINT(RT_DEBUG_WARN,("\n\n"));
 	for (pos = offset; pos < (offset+len); pos += 4)
 	{
-		value = (UINT32 *)(pRaCfg->data + 2 + sizeof(offset) + sizeof(len) + (pos - offset));
+		value = (UINT32 *)pRaCfg->data + 2 + sizeof(offset) + sizeof(len) + (pos - offset);
 		mt_rf_write(pAd, bank, pos, *value);
 //		DBGPRINT(RT_DEBUG_WARN,("rf bank%u w R%u=0x%02X\n", bank, pos, *value));
 		DBGPRINT(RT_DEBUG_WARN,("iwpriv %s0 set rf=%u-%u-%02X\n"
@@ -3298,14 +3298,12 @@ static  INT DO_RACFG_CMD_ATE_TXBF_VERIFY_NOCOMP(
 }
 #endif /* TXBF_SUPPORT */
 
-
+#ifdef MT76x2
 static  INT DO_RACFG_CMD_ATE_GET_HW_COUNTER(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	RTMP_IOCTL_INPUT_STRUCT	*wrq,
 	IN  struct ate_racfghdr *pRaCfg)
-{
-	PATE_INFO pATEInfo = &(pAd->ate);
-	
+{	
 	DBGPRINT(RT_DEBUG_TRACE,("DO_RACFG_CMD_ATE_GET_HW_COUNTER\n"));
 
 	memcpy_exl(pAd, &pRaCfg->data[0], (UCHAR *)&pAd->WlanCounters.FCSErrorCount.u.LowPart, 4);
@@ -3317,7 +3315,7 @@ static  INT DO_RACFG_CMD_ATE_GET_HW_COUNTER(
 
 	return NDIS_STATUS_SUCCESS;
 }
-
+#endif /* MT76x2 */
 
 static INT32 DO_RACFG_CMD_ATE_SHOW_PARAM(
 	IN	PRTMP_ADAPTER	pAd,
diff --git a/mt76x2/ate/include/rt_ate.h b/mt76x2/ate/include/rt_ate.h
old mode 100644
new mode 100755
index b956434..578f615
--- a/mt76x2/ate/include/rt_ate.h
+++ b/mt76x2/ate/include/rt_ate.h
@@ -57,6 +57,39 @@
 #define BBP_R182			182
 // TODO: ---End
 
+#define BIT0    (1 << 0)
+#define BIT1	(1 << 1)
+#define BIT2	(1 << 2)
+#define BIT3	(1 << 3)
+#define BIT4	(1 << 4)
+#define BIT5	(1 << 5)
+#define BIT6	(1 << 6)
+#define BIT7	(1 << 7)
+#define BIT8	(1 << 8)
+#define BIT9	(1 << 9)
+#define BIT10	(1 << 10)
+#define BIT11	(1 << 11)
+#define BIT12	(1 << 12)
+#define BIT13	(1 << 13)
+#define BIT14	(1 << 14)
+#define BIT15	(1 << 15)
+#define BIT16	(1 << 16)
+#define BIT17	(1 << 17)
+#define BIT18	(1 << 18)
+#define BIT19	(1 << 19)
+#define BIT20	(1 << 20)
+#define BIT21	(1 << 21)
+#define BIT22	(1 << 22)
+#define BIT23	(1 << 23)
+#define BIT24	(1 << 24)
+#define BIT25	(1 << 25)
+#define BIT26	(1 << 26)
+#define BIT27	(1 << 27)
+#define BIT28	(1 << 28)
+#define BIT29	(1 << 29)
+#define BIT30	(1 << 30)
+#define BIT31	(1 << 31)
+
 typedef struct _ATE_CHIP_STRUCT {
 	/* functions */
 	VOID	(*ChannelSwitch)(PRTMP_ADAPTER pAd);
@@ -153,6 +186,8 @@ typedef struct _ATE_INFO {
 	BOOLEAN bDPDEnable;	/* Set DPD Calibration Enable */
 #endif /* RT6352 */
 	BOOLEAN bLowTemperature; /* Trigger Temperature Sensor */
+	BOOLEAN bTestTimeReduction;/* Set ATE test time reduction. */
+	
 #ifdef RTMP_INTERNAL_TX_ALC
 #if defined(RT3350) || defined(RT3352)
 	BOOLEAN bTSSICalbrEnableG; /* Enable TSSI calibration */
@@ -692,7 +727,7 @@ CHAR ATEGetDesiredTSSI(
 
 #endif /* RTMP_INTERNAL_TX_ALC */
 
-#ifdef RTMP_TEMPERATURE_CALIBRATION
+#if defined(RTMP_TEMPERATURE_CALIBRATION) || defined(RTMP_TEMPERATURE_COMPENSATION)
 INT Set_ATE_TEMP_CAL_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg);
@@ -700,7 +735,7 @@ INT Set_ATE_TEMP_CAL_Proc(
 INT Set_ATE_SHOW_TSSI_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg);
-#endif /* RTMP_TEMPERATURE_CALIBRATION */
+#endif /* defined(RTMP_TEMPERATURE_CALIBRATION) || defined(RTMP_TEMPERATURE_COMPENSATION) */
 
 #ifdef RT6352
 #ifdef RTMP_TEMPERATURE_CALIBRATION
@@ -712,6 +747,7 @@ INT RT6352_ATETempCalibration(
 
 #ifdef RTMP_TEMPERATURE_COMPENSATION
 
+
 INT Set_ATE_READ_EXTERNAL_TSSI_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg);
@@ -903,6 +939,20 @@ INT	Set_ATE_TXSOUNDING_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg);
 
+INT ate_txbf_get_chan_idx(
+    IN RTMP_ADAPTER *pAd,
+	IN UCHAR channel,
+	IN UCHAR mode);
+
+INT ate_txbf_chan_group_base_idx(
+    IN RTMP_ADAPTER *pAd,
+	IN UCHAR channel);
+
+BOOLEAN rtmp_ate_txbf_fix_tank_code(
+         IN RTMP_ADAPTER *pAd,
+         IN UCHAR channel,
+         IN BOOLEAN  CalibMode);
+
 INT	Set_ATE_TXBF_DIVCAL_Proc(
 	IN	PRTMP_ADAPTER	pAd,
 	IN	PSTRING			arg);
@@ -925,12 +975,20 @@ INT Set_ATE_TXBF_Gd_Verify_Proc(
 
 INT Set_ATE_TXBF_Gd_Verify_NoComp_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
-	IN	PSTRING			arg);
+	IN  PSTRING         arg);
 
 INT Set_ATE_TXBF_Gd_Phase_Cal_and_Verify_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg);
 
+INT Set_ATE_TXBF_Gd_Phase_Cal_Init_Verify_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg);
+
+INT Set_ATE_TXBF_Gd_Check_Error_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg);
+
 #ifdef MT76x2
 int Set_ATE_TXBF_Intloop_Cal_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
@@ -955,6 +1013,10 @@ INT Set_ATE_ForceBBP_Proc(
 #endif /* TXBF_SUPPORT */
 
 
+INT	Set_ATE_TTR_Proc(
+	IN	PRTMP_ADAPTER	pAd, 
+	IN	PSTRING			arg);
+
 INT	Set_ATE_Show_Proc(
 	IN	PRTMP_ADAPTER	pAd, 
 	IN	PSTRING			arg);
diff --git a/mt76x2/ate/include/rt_qa.h b/mt76x2/ate/include/rt_qa.h
old mode 100644
new mode 100755
diff --git a/mt76x2/chips/mt76x2.c b/mt76x2/chips/mt76x2.c
index 0314d5f..0a4c8fe 100644
--- a/mt76x2/chips/mt76x2.c
+++ b/mt76x2/chips/mt76x2.c
@@ -1675,7 +1675,7 @@ void mt76x2_calibration(RTMP_ADAPTER *ad, u8 channel)
         }
 		NdisGetSystemUpTime(&stTimeChk1);
 	
-		DBGPRINT(RT_DEBUG_INFO,("%s : Divider calibration duration = %d ms\n", __FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
+		DBGPRINT(RT_DEBUG_INFO,("%s : Divider calibration duration = %ld ms\n", __FUNCTION__, (stTimeChk1 - stTimeChk0)*1000/OS_HZ));
 	}
 #endif /* TXBF_SUPPORT */	
 
diff --git a/mt76x2/common/action.c b/mt76x2/common/action.c
index 84936b6..bcf43e0 100644
--- a/mt76x2/common/action.c
+++ b/mt76x2/common/action.c
@@ -1328,12 +1328,13 @@ VOID PeerVHTAction(RTMP_ADAPTER *pAd, MLME_QUEUE_ELEM *Elem)
 #ifdef VHT_TXBF_SUPPORT
 		case ACT_VHT_COMPRESS_BF:
 			{
-				//DBGPRINT(RT_DEBUG_OFF,("ACTION - VHT Compressed Beamforming action---->\n"));
-				//hex_dump("VHT Compressed BF", &Elem->Msg[0], Elem->MsgLen);
+				DBGPRINT(RT_DEBUG_TRACE,("ACTION - VHT Compressed Beamforming action---->\n"));
+				DBGPRINT(RT_DEBUG_TRACE, ("%s", (hex_dump("VHT Compressed BF", &Elem->Msg[0], Elem->MsgLen), "\n")));
 				break;
 			}
 #endif /* VHT_TXBF_SUPPORT */
 		default:
+			DBGPRINT(RT_DEBUG_TRACE, ("ACTION - Unsupported VHT action(%u)\n", Action));
 			break;
 	}
 }
diff --git a/mt76x2/common/cmm_info.c b/mt76x2/common/cmm_info.c
index 7d0bd97..14d5eb1 100644
--- a/mt76x2/common/cmm_info.c
+++ b/mt76x2/common/cmm_info.c
@@ -7444,7 +7444,7 @@ INT	Set_ETxBfEnCond_Proc(
 				(pAd->CommonCfg.Channel > 14))
 				pEntry->eTxBfEnCond = clientSupportsVHTETxBF(pAd, &pEntry->vht_cap_ie.vht_cap) ? enableETxBf: 0;
 			else
-#endif
+#endif /* VHT_TXBF_SUPPORT */
 				pEntry->eTxBfEnCond = clientSupportsETxBF(pAd, &pEntry->HTCapability.TxBFCap)? enableETxBf: 0;
 			pEntry->bfState = READY_FOR_SNDG0;
 			pEntry->HTPhyMode.field.eTxBF = pEntry->eTxBfEnCond;
@@ -7454,8 +7454,9 @@ INT	Set_ETxBfEnCond_Proc(
 #endif /* MCS_LUT_SUPPORT */
 		}
 
-		DBGPRINT(RT_DEBUG_TRACE, ("Set ETxBfEn=%d, Final ETxBF status =%d!\n",
-					enableETxBf , pEntry->eTxBfEnCond));
+		if (!MAC_ADDR_EQUAL(pEntry->Addr, ZERO_MAC_ADDR))
+			DBGPRINT(RT_DEBUG_WARN, ("[ %02x:%02x:%02x:%02x:%02x:%02x ] Set ETxBfEn=%d, Final ETxBF status =%d!\n",
+					PRINT_MAC(pEntry->Addr), enableETxBf , pEntry->eTxBfEnCond));
 	}
 
 
diff --git a/mt76x2/common/cmm_profile.c b/mt76x2/common/cmm_profile.c
index 85830e1..6a7d39b 100644
--- a/mt76x2/common/cmm_profile.c
+++ b/mt76x2/common/cmm_profile.c
@@ -3600,7 +3600,7 @@ NDIS_STATUS	RTMPSetProfileParameters(
 			if(RTMPGetKeyParameter("ITxBfCalibMode", tmpbuf, 32, pBuffer, TRUE))
 			{
 				pAd->CommonCfg.ITxBfCalibMode = simple_strtol(tmpbuf, 0, 10);
-				DBGPRINT(RT_DEBUG_TRACE, ("ITxBfCalibMode = %ld\n", pAd->CommonCfg.ITxBfCalibMode));
+				DBGPRINT(RT_DEBUG_TRACE, ("ITxBfCalibMode = %d\n", pAd->CommonCfg.ITxBfCalibMode));
 			}
 
 			/* ETxBfeeEn*/
diff --git a/mt76x2/common/cmm_txbf.c b/mt76x2/common/cmm_txbf.c
index edfbf7c..ad0d1e9 100644
--- a/mt76x2/common/cmm_txbf.c
+++ b/mt76x2/common/cmm_txbf.c
@@ -276,6 +276,9 @@ BOOLEAN rtmp_chk_itxbf_calibration(
 	else
 	{
         bCalibrated = ITxBFGetEEPROM(pAd, &phaseParams, 0, 0, 0);
+		if (bCalibrated == FALSE) {
+			DBGPRINT(RT_DEBUG_TRACE, ("EEPROM no valid calibration value in eeprom!\n"));
+		}
 	}
 
 #endif /*MT76x2*/
diff --git a/mt76x2/include/mac_ral/nmac/ral_nmac.h b/mt76x2/include/mac_ral/nmac/ral_nmac.h
index 1aa5874..bc35b24 100644
--- a/mt76x2/include/mac_ral/nmac/ral_nmac.h
+++ b/mt76x2/include/mac_ral/nmac/ral_nmac.h
@@ -133,9 +133,9 @@ typedef struct GNU_PACKED _TXWI_NMAC {
 	
 	UINT32		lut_en:1;
 	UINT32		Sounding:1;
-	UINT32		NDPSndBW:2;	/* NDP sounding BW */
+	UINT32		NDPSndBW:1;	/* NDP sounding BW */
 	UINT32		RTSBWSIG:1;
-	UINT32		NDPSndRate:1;	/* 0 : MCS0, 1: MCS8, 2: MCS16, 3: reserved */
+	UINT32		NDPSndRate:2;	/* 0 : MCS0, 1: MCS8, 2: MCS16, 3: reserved */
 	UINT32		txop:2;
 
 	UINT32		MpduDensity:3;
@@ -180,9 +180,9 @@ typedef	struct GNU_PACKED _TXWI_NMAC {
 	UINT32		MpduDensity:3;
 
 	UINT32		txop:2;
-	UINT32		NDPSndRate:1; /* 0 : MCS0, 1: MCS8, 2: MCS16, 3: reserved */
+	UINT32		NDPSndRate:2; /* 0 : MCS0, 1: MCS8, 2: MCS16, 3: reserved */
 	UINT32		RTSBWSIG:1;
-	UINT32		NDPSndBW:2; /* NDP sounding BW */
+	UINT32		NDPSndBW:1; /* NDP sounding BW, since NDPSndRate Need 2bit, I split one for it, hope this won't damage too large *By Lea* */
 	UINT32		Sounding:1;
 	UINT32		lut_en:1;
 	
-- 
2.10.1

